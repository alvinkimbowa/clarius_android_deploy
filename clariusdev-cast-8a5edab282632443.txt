Directory structure:
└── clariusdev-cast/
    ├── README.md
    ├── LICENSE
    ├── examples/
    │   ├── cast_android/
    │   │   ├── README.md
    │   │   ├── gradle.properties
    │   │   ├── gradlew
    │   │   ├── gradlew.bat
    │   │   ├── app/
    │   │   │   ├── proguard-rules.pro
    │   │   │   └── src/
    │   │   │       └── main/
    │   │   │           ├── AndroidManifest.xml
    │   │   │           ├── java/
    │   │   │           │   └── me/
    │   │   │           │       └── clarius/
    │   │   │           │           └── sdk/
    │   │   │           │               └── cast/
    │   │   │           │                   └── example/
    │   │   │           │                       ├── CastService.java
    │   │   │           │                       ├── FirstFragment.java
    │   │   │           │                       ├── ImageConverter.java
    │   │   │           │                       ├── IOUtils.java
    │   │   │           │                       ├── MainActivity.java
    │   │   │           │                       └── Utils.java
    │   │   │           └── res/
    │   │   │               ├── drawable/
    │   │   │               │   ├── ic_baseline_image.xml
    │   │   │               │   ├── ic_launcher_background.xml
    │   │   │               │   └── ic_launcher_foreground.xml
    │   │   │               ├── layout/
    │   │   │               │   ├── activity_main.xml
    │   │   │               │   ├── content_main.xml
    │   │   │               │   └── fragment_first.xml
    │   │   │               ├── menu/
    │   │   │               │   └── menu_main.xml
    │   │   │               ├── mipmap-anydpi-v26/
    │   │   │               │   ├── ic_launcher.xml
    │   │   │               │   └── ic_launcher_round.xml
    │   │   │               ├── mipmap-hdpi/
    │   │   │               │   ├── ic_launcher.webp
    │   │   │               │   └── ic_launcher_round.webp
    │   │   │               ├── mipmap-mdpi/
    │   │   │               │   ├── ic_launcher.webp
    │   │   │               │   └── ic_launcher_round.webp
    │   │   │               ├── mipmap-xhdpi/
    │   │   │               │   ├── ic_launcher.webp
    │   │   │               │   └── ic_launcher_round.webp
    │   │   │               ├── mipmap-xxhdpi/
    │   │   │               │   ├── ic_launcher.webp
    │   │   │               │   └── ic_launcher_round.webp
    │   │   │               ├── mipmap-xxxhdpi/
    │   │   │               │   ├── ic_launcher.webp
    │   │   │               │   └── ic_launcher_round.webp
    │   │   │               ├── navigation/
    │   │   │               │   └── nav_graph.xml
    │   │   │               ├── values/
    │   │   │               │   ├── colors.xml
    │   │   │               │   ├── dimens.xml
    │   │   │               │   ├── strings.xml
    │   │   │               │   └── themes.xml
    │   │   │               ├── values-land/
    │   │   │               │   └── dimens.xml
    │   │   │               ├── values-night/
    │   │   │               │   └── themes.xml
    │   │   │               ├── values-w1240dp/
    │   │   │               │   └── dimens.xml
    │   │   │               ├── values-w600dp/
    │   │   │               │   └── dimens.xml
    │   │   │               └── xml/
    │   │   │                   ├── backup_rules.xml
    │   │   │                   └── data_extraction_rules.xml
    │   │   └── gradle/
    │   │       └── wrapper/
    │   │           └── gradle-wrapper.properties
    │   ├── cast_split/
    │   │   ├── CaptureLabel.swift
    │   │   ├── CastModel.swift
    │   │   ├── ContentView.swift
    │   │   ├── iOS-Bridging-Header.h
    │   │   ├── macOS-Bridging-Header.h
    │   │   ├── Measurement.swift
    │   │   ├── Operations.swift
    │   │   ├── Scanner.swift
    │   │   ├── SideBySide-Info.plist
    │   │   ├── SideBySide.entitlements
    │   │   ├── SideBySideApp.swift
    │   │   ├── Assets.xcassets/
    │   │   │   ├── Contents.json
    │   │   │   ├── AccentColor.colorset/
    │   │   │   │   └── Contents.json
    │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   └── Contents.json
    │   │   │   └── BlankImage.imageset/
    │   │   │       └── Contents.json
    │   │   ├── ios/
    │   │   │   ├── Launch Screen.storyboard
    │   │   │   └── plist.in
    │   │   └── SideBySide (MacOS)/
    │   │       └── SideBySide__MacOS_.entitlements
    │   ├── cast_swift/
    │   │   ├── Cast-Example--iOS--Info.plist
    │   │   ├── Cast-Example--macOS--Info.plist
    │   │   ├── macOS/
    │   │   │   └── macOS.entitlements
    │   │   └── Shared/
    │   │       ├── BluetoothModel.swift
    │   │       ├── Cast Example (iOS)-Bridging-Header.h
    │   │       ├── Cast Example (macOS)-Bridging-Header.h
    │   │       ├── Cast_ExampleApp.swift
    │   │       ├── CastModel.swift
    │   │       ├── ContentView.swift
    │   │       ├── Scanner.swift
    │   │       ├── ScannerList.swift
    │   │       ├── ScannersModel.swift
    │   │       └── Assets.xcassets/
    │   │           ├── Contents.json
    │   │           ├── AccentColor.colorset/
    │   │           │   └── Contents.json
    │   │           ├── AppIcon.appiconset/
    │   │           │   └── Contents.json
    │   │           └── BlankImage.imageset/
    │   │               └── Contents.json
    │   ├── caster/
    │   │   ├── caster.pro
    │   │   ├── main.cpp
    │   │   └── Makefile
    │   ├── caster_qt/
    │   │   ├── 3d.cpp
    │   │   ├── 3d.h
    │   │   ├── caster.cpp
    │   │   ├── caster.h
    │   │   ├── caster.pro
    │   │   ├── caster.qrc
    │   │   ├── caster.ui
    │   │   ├── CMakeLists.txt
    │   │   ├── display.cpp
    │   │   ├── display.h
    │   │   ├── main.cpp
    │   │   ├── pch.h
    │   │   ├── macos/
    │   │   │   └── Info.plist
    │   │   └── res/
    │   │       ├── c3.mtl
    │   │       ├── l15.mtl
    │   │       └── l20.mtl
    │   └── python/
    │       ├── README.md
    │       ├── pycaster.py
    │       ├── pyimu.py
    │       ├── pysidecaster.py
    │       └── scanner.mtl
    ├── include/
    │   └── cast/
    │       ├── cast.h
    │       ├── cast_cb.h
    │       ├── cast_def.h
    │       └── cast_export.h
    └── .github/
        └── ISSUE_TEMPLATE/
            └── bug_report.md

================================================
FILE: README.md
================================================
Clarius Cast API
================

This repository contains all related items for the Clarius Cast API

# Download

https://github.com/clariusdev/cast/releases

# Overview

The Cast API is based on the Clarius Cast protocol that the Clarius App uses for streaming images to multiple clients at once. Its primary use is for research purposes when access to real-time images is required, the Cast API provides a relatively simple way to get started. The pure C API is deployed on desktop only, primarily because Clarius uses Qt heavily, a library that can often introduce difficulties when deploying or linking on mobile platforms. For commercial users wanting to deploy on mobile, Clarius has created a Java version specifically for interfacing to the Clarius App in an Android environment and an Objective-C framework specifically for interfacing to the Clarius App in an iOS environment.

The Cast API does provide some mechanisms for control of the ultrasound probe, such as the ability to freeze, change parameters such as depth and gain; however these are generally considered secondary functions, as the main purpose of the Cast API is to easily obtain the images in real-time, as opposed to duplicating a control interface.

# Features

- Obtain greyscale and color Doppler **images** (cartesian data) in real-time over the wireless network
- Obtain greyscale and color Doppler **raw images** (polar co-ordinate data) in real-time over the wireless network
- Obtain **9-DOF IMU** data in real-time over the wireless network **
- Obtain **raw data** such as IQ and RF signals once imaging is frozen **
- Obtain interleaved **RF** signals in real-time **
- Set **dimensions** of output images
- Work over a **wireless LAN** or on the **probe's Wi-Fi** network
- Notifications for imaging **freeze and button presses**
- Ability to **freeze** imaging, change basic **imaging parameters**, and change **imaging modes**

** separate software licensing may be required for features to function

# Constraints

- Must be executed while the **Clarius App is running** and connected to a probe, can be the same or different mobile device/PC
- Probe, mobile device, and PC/device must be on the **same wireless network**
- Raw data can only be captured while **imaging is frozen**, except when RF streaming is enabled from the App, in which RF frames are interleaved and streamed over the Cast API when there is a connection

# Releases

- New API binaries and source code get published when Clarius releases a new App
- APIs must be updated to the latest version, there is no backwards or forwards compatibility with older/newer Apps due to a probe firmware check that the library performs upon a connection
- Binaries can be obtained in the [releases](https://github.com/clariusdev/cast/releases) section of the GitHub repositories

# Architecture

The Cast API communicates with the _Clarius Probe_ directly, and makes use of TCP technologies to create a secondary connection to the device that is able to receive images.


```mermaid
  flowchart LR
  prb[Probe]
  subgraph mobile[Mobile Device]
    app[Clarius App]
  end
  subgraph pc[PC]
    cast[Cast Application]
  end
  prb<-- Primary Connection -->app
  prb<-- Cast Connection -->cast
```

# Supported Platforms

- **Windows**: Tested on Windows 10
- **Linux**: Tested on Ubuntu 20.04 and higher
- **macOS**: Tested on macOS 10.15 and higher
- **iOS**: Tested on iOS 13 or higher (note that clients wanting to run side-by-side on same device must use **iPadOS**)
- **Android**: Tested on Android 10 or higher

# Repository

Structure:

    .
    └── examples
        ├── cast_android        Android example program
        ├── cast_split          iOS example program
        ├── cast_swift          iOS example program
        ├── caster              desktop example program
        ├── caster_qt           desktop example program
        └── python              python examples (import pyclariuscast modules from release package)

Headers are located in the binaries in the Release section.

Desktop Examples:

- **caster** a simple standalone command-line program that must be run with proper input arguments. The Windows version currently requires the boost c++ libraries to be installed for program argument parsing. Images cannot be viewed, however data/images can be captured. A Linux makefile and a Visual Studio solution have been created to help with compilation.
- **caster_qt** a graphical program that allows real-time viewing of the ultrasound stream and implements more functionality than the console program. A Qt Creator project file has been created to help with compilation. A valid compiler and Qt binaries should be installed in order for a proper kit to be defined within the IDE.

iOS Example:

- **cast_swift** a simple SwiftUI program that demonstrates some of the features of the framework. To build, the full iOS framework zip must be extracted to the ../../Library/Frameworks/ path or the path must be adjusted in the project settings. A signing certificate must be specified in the project settings. Ensure that the build target is iOS 64-bit arm to match the downloaded framework. The program demonstrates populating scanner details via bluetooth and image streaming.

Typical Usage:
```
init(callbacks, dimensions)
connect(network_params)

while (input)
  performAction(input)
 
imageCallback(image)
{
  processImage(image)
}
```

# Network Information

The Clarius App will display the network information on a top bar above the image for any probe licensed for the Cast API. The port and IP address are required to make a connection through the Cast API.

|<img height="250px" alt="connection in progress" src="blob/1.png"/>|<img height="250px" alt="connected" src="blob/2.png"/>|

Licenced probes also have the option for forcing the port by adjusting the Clarius Cast Permission setting within the App to "Research". This provides a potentially more streamlined method when automating connections from the custom software.

|<img height="250px" alt="setting" src="blob/3.png"/>|

Since most connections will be made using the probe's own Wi-Fi network, it is important to ensure the computer running the Cast program is on the same network. Probe networks are typically prefixed with "DIRECT-", and the password is available for 60 seconds on the mobile device clipboard once the Clarius App has connected.

# Notes

- When running under Windows, execution may require temporarily disabling the firewall defender or adding an exception for the executable - the latter is recommended. This is due to the use of randomized ports that the API makes use of for streaming images.



================================================
FILE: LICENSE
================================================
BSD 3-Clause License

Copyright (c) 2020, Clarius Mobile Health
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
FILE: examples/cast_android/README.md
================================================
# Clarius Cast Example

1. Copy the `aar` package into the `libs` subfolder
2. Re-sync Gradle
3. Build

## Important Notes

* Set the DSL option `useLegacyPackaging = true` in the application's `build.gradle`, this ensures the native libraries are extracted and can be loaded at runtime because the current implementation does not support loading uncompressed libraries from the APK:

## Marketplace Integration

### Launcher

The Clarius app can launch partner apps with an Android intent containing the probe connection info in the intent's extras:

| Key | Description | Type |
|-----|-------------|------|
| `cus_probe_serial` | probe serial | UTF-8 string in a `byte[]` |
| `cus_ip_address` | probe's IP address | UTF-8 string in a `byte[]` |
| `cus_cast_port` | probe's TCP port | Integer encoded in a `byte[]` |
| `cus_network_id` | probe's network ID | Integer encoded in a `byte[]` |

### Visibility

The Clarius app attempts to detect installed partner apps by querying the `PackageManager` to adapt its GUI.
However, starting with Android 11 (API 30), results are filtered by the system, preventing detection.
To allow detection, ensure your target activity declares an intent filter in the manifest file with either of the following actions:

* `android.intent.action.MAIN`
* `me.clarius.sdk.action.LAUNCH`

For example:

    <application>
        <activity>
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <action android:name="me.clarius.sdk.action.LAUNCH" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

## TODO

* Provide a multi-ABI package



================================================
FILE: examples/cast_android/gradle.properties
================================================
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# https://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# https://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
org.gradle.warning.mode=all



================================================
FILE: examples/cast_android/gradlew
================================================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"



================================================
FILE: examples/cast_android/gradlew.bat
================================================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega



================================================
FILE: examples/cast_android/app/proguard-rules.pro
================================================
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   https://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile



================================================
FILE: examples/cast_android/app/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- INTERNET perm required to connect to network sockets -->
    <uses-permission android:name="android.permission.INTERNET" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:usesCleartextTraffic="false"
        android:theme="@style/Theme.CastExample"
        tools:targetApi="31">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.CastExample.NoActionBar">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <!-- Make the example app visible to the clarius app
                to improve user workflow when launching marketplace apps -->
                <action android:name="me.clarius.sdk.action.LAUNCH" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <service android:name=".CastService"
            android:enabled="true"
            android:exported="false" />

    </application>

</manifest>



================================================
FILE: examples/cast_android/app/src/main/java/me/clarius/sdk/cast/example/CastService.java
================================================
package me.clarius.sdk.cast.example;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Binder;
import android.os.IBinder;
import android.util.Log;

import androidx.annotation.Nullable;
import androidx.lifecycle.MutableLiveData;

import java.nio.ByteBuffer;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import me.clarius.sdk.Button;
import me.clarius.sdk.Cast;
import me.clarius.sdk.Platform;
import me.clarius.sdk.PosInfo;
import me.clarius.sdk.ProcessedImageInfo;
import me.clarius.sdk.RawImageInfo;
import me.clarius.sdk.SpectralImageInfo;

public class CastService extends Service {
    private static final String TAG = "Cast";
    private static final String NONE = "<none>";
    private final MutableLiveData<Bitmap> processedImage = new MutableLiveData<>();
    private final MutableLiveData<Long> imageTime = new MutableLiveData<>();
    private final MutableLiveData<String> error = new MutableLiveData<>();
    private final MutableLiveData<Integer> rawDataProgress = new MutableLiveData<>();
    private final IBinder binder = new CastBinder();
    private final ExecutorService executorService = Executors.newFixedThreadPool(1);
    private final ImageConverter converter = new ImageConverter(executorService, new ImageConverter.Callback() {
        @Override
        public void onResult(Bitmap bitmap, long timestamp) {
            processedImage.postValue(bitmap);
            imageTime.postValue(timestamp);
        }

        @Override
        public void onError(Exception e) {
            error.postValue(e.toString());
        }
    });
    private final Cast.Listener listener = new Cast.Listener() {

        @Override
        public void error(String e) {
            error.postValue(e);
        }

        @Override
        public void freeze(boolean frozen) {
            Log.d(TAG, "Freeze: " + frozen);
        }

        @Override
        public void newProcessedImage(ByteBuffer data, ProcessedImageInfo info, PosInfo[] pos) {
            converter.convertImage(data, info);
        }

        @Override
        public void newRawImageFn(ByteBuffer data, RawImageInfo info, PosInfo[] pos) {
        }

        @Override
        public void newSpectralImageFn(ByteBuffer data, SpectralImageInfo info) {
        }

        @Override
        public void newImuDataFn(PosInfo pos) {
        }

        @Override
        public void progress(int i) {
            rawDataProgress.postValue(i);
        }

        @Override
        public void buttonPressed(Button button, int count) {
            Log.d(TAG, "Button '" + button + " pressed " + count + " time(s)");
        }
    };
    private Cast cast;

    private static String getCertDir(Context context) {
        return context.getDir("cert", Context.MODE_PRIVATE).toString();
    }

    @Override
    public void onCreate() {
        super.onCreate();
        if (cast == null) {
            Log.d(TAG, "Creating the Cast service");
            cast = new Cast(getApplicationContext().getApplicationInfo().nativeLibraryDir, listener);
            cast.initialize(getCertDir(this), new Cast.BooleanResult() {
                @Override
                public void accept(boolean result) {
                    Log.d(TAG, "Initialization result: " + result);
                    if (result) {
                        cast.getFirmwareVersion(Platform.V1, optional -> Log.i(TAG, "Firmware " + Platform.V1 + ": " + optional.orElse(NONE)));
                        cast.getFirmwareVersion(Platform.HD, optional -> Log.i(TAG, "Firmware " + Platform.HD + ": " + optional.orElse(NONE)));
                        cast.getFirmwareVersion(Platform.HD3, optional -> Log.i(TAG, "Firmware " + Platform.HD3 + ": " + optional.orElse(NONE)));
                    }
                }
            });
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (cast != null) {
            Log.d(TAG, "Destroying the Cast service");
            cast.disconnect(null);
            cast.release();
            cast = null;
        }
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        Log.d(TAG, "Binding to the Cast service");
        return binder;
    }

    /**
     * The Binder is the interface to our service.
     */
    public class CastBinder extends Binder {
        public Cast getCast() {
            return cast;
        }

        public MutableLiveData<Bitmap> getProcessedImage() {
            return processedImage;
        }

        public MutableLiveData<Long> getTimestamp() {
            return imageTime;
        }

        public MutableLiveData<String> getError() {
            return error;
        }

        public MutableLiveData<Integer> getRawDataProgress() {
            return rawDataProgress;
        }
    }
}



================================================
FILE: examples/cast_android/app/src/main/java/me/clarius/sdk/cast/example/FirstFragment.java
================================================
package me.clarius.sdk.cast.example;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Optional;

import me.clarius.sdk.Cast;
import me.clarius.sdk.ProbeInfo;
import me.clarius.sdk.UserFunction;
import me.clarius.sdk.cast.example.databinding.FragmentFirstBinding;

public class FirstFragment extends Fragment {

    private static final String TAG = "Cast";

    private FragmentFirstBinding binding;
    private CastService.CastBinder castBinder;
    private Long timestamp = 0L;

    /**
     * Defines callbacks for service binding, passed to bindService()
     */
    private final ServiceConnection castConnection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName className, IBinder service) {
            Log.d(TAG, "service connected");
            // We've bound to our service, cast the IBinder now
            castBinder = (CastService.CastBinder) service;
            castBinder.getProcessedImage().observe(getViewLifecycleOwner(), binding.imageView::setImageBitmap);
            castBinder.getTimestamp().observe(getViewLifecycleOwner(), FirstFragment.this::setTimestamp);
            castBinder.getError().observe(getViewLifecycleOwner(), FirstFragment.this::showError);
            castBinder.getRawDataProgress().observe(getViewLifecycleOwner(), binding.rawDataDownloadProgressBar::setProgress);
        }

        @Override
        public void onServiceDisconnected(ComponentName component) {
            Log.d(TAG, "service disconnected");
            castBinder = null;
        }
    };

    private static String fromByteArray(final byte[] from) {
        return new String(from, StandardCharsets.UTF_8);
    }

    private static void askProbeInfo(Cast cast) {
        cast.getProbeInfo(info -> Log.d(TAG, "Probe info: " + info.map(FirstFragment::probeInfoToString).orElse("<none>")));
    }

    public static String probeInfoToString(final ProbeInfo info) {
        StringBuilder b = new StringBuilder();
        b.append("v").append(info.version).append(" elements: ").append(info.elements).append(" pitch: ").append(info.pitch).append(" radius: ").append(info.radius);
        return b.toString();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentFirstBinding.inflate(inflater, container, false);
        return binding.getRoot();
    }

    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        binding.buttonConnect.setOnClickListener(v -> doConnect());
        binding.buttonRun.setOnClickListener(v -> toggleRun());
        binding.buttonDisconnect.setOnClickListener(v -> doDisconnect());
        binding.buttonRawData.setOnClickListener(v -> getRawData());
        binding.buttonCapture.setOnClickListener(v -> doCapture());
    }

    @Override
    public void onResume() {
        super.onResume();
        final Intent intent = this.requireActivity().getIntent();
        if (intent != null) {
            final Bundle extras = intent.getExtras();
            if (extras != null) {
                final Optional<String> probeSerial = Optional.ofNullable(extras.getByteArray("cus_probe_serial")).map(FirstFragment::fromByteArray);
                final Optional<String> ipAddress = Optional.ofNullable(extras.getByteArray("cus_ip_address")).map(FirstFragment::fromByteArray);
                final Optional<String> castPort = Optional.ofNullable(extras.getByteArray("cus_cast_port")).map(FirstFragment::fromByteArray);
                final Optional<String> networkId = Optional.ofNullable(extras.getByteArray("cus_network_id")).map(FirstFragment::fromByteArray);
                Log.d(TAG, "Received probe serial: " + probeSerial.orElse("<none>"));
                Log.d(TAG, "Received IP address: " + ipAddress.orElse("<none>"));
                Log.d(TAG, "Received cast port: " + castPort.orElse("<none>"));
                Log.d(TAG, "Received network ID: " + networkId.orElse("<none>"));
                ipAddress.ifPresent(s -> binding.ipAddress.setText(s));
                castPort.ifPresent(s -> binding.tcpPort.setText(s));
                networkId.ifPresent(s -> binding.networkId.setText(s));
            }
        }
    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Context context = requireContext();
        Intent intent = new Intent(context, CastService.class);
        context.bindService(intent, castConnection, Context.BIND_AUTO_CREATE);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Context context = requireContext();
        context.unbindService(castConnection);
        castBinder = null;
    }

    private void toggleRun() {
        if (castBinder == null) {
            showError("Clarius Cast not initialized");
            return;
        }
        showMessage("Toggle run");
        castBinder.getCast().userFunction(UserFunction.Freeze, 0, result -> Log.d(TAG, "Freeze function result: " + result));
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }

    private void doConnect() {
        if (castBinder == null) {
            showError("Clarius Cast not initialized");
            return;
        }
        binding.ipAddressLayout.setError(null);
        binding.tcpPortLayout.setError(null);
        String ipAddress = String.valueOf(binding.ipAddress.getText());
        if (ipAddress.isEmpty()) {
            binding.ipAddressLayout.setError("Cannot be empty");
            return;
        }
        Optional<Integer> tcpPort = Utils.maybeInt(binding.tcpPort.getText());
        if (!tcpPort.isPresent()) {
            binding.tcpPortLayout.setError("Invalid number");
            return;
        }
        Optional<Long> networkId = Utils.maybeLong(binding.networkId.getText());
        showMessage("Connecting to " + ipAddress + ":" + tcpPort.get());
        castBinder.getCast().connect(ipAddress, tcpPort.get(), networkId, getCertificate(), (result, imagePort, imuPort, swRevMatch) -> {
            Log.d(TAG, "Connection result: " + result);
            if (result) {
                Log.d(TAG, "UDP stream will be on port " + imagePort);
                Log.d(TAG, "IMU stream will be on port " + imuPort);
                Log.d(TAG, "App software " + (swRevMatch ? "matches" : "does not match"));
                askProbeInfo(castBinder.getCast());
            }
        });
    }

    private void doDisconnect() {
        if (castBinder == null) {
            return;
        }
        castBinder.getCast().disconnect(result -> Log.d(TAG, "Disconnection result: " + result));
    }

    private void getRawData() {
        if (castBinder == null) {
            return;
        }
        showMessage("Requesting raw data");
        binding.rawDataDownloadProgressBar.setProgress(0);
        final Cast cast = castBinder.getCast();
        RawDataFile handle = new RawDataFile(cast);
        final int start = 0;
        final int end = 0;
        final boolean lzo = true;
        cast.requestRawData(start, end, lzo, handle::requestResultRetrieved);
    }

    private void doCapture() {
        if (castBinder == null || timestamp == 0L) {
            return;
        }
        showMessage("Starting image capture");
        castBinder.getCast().startCapture(timestamp, captureID -> {
            Log.d(TAG, "Start capture got ID: " + captureID);
            if (captureID < 0) {
                return;
            }
            castBinder.getCast().finishCapture(captureID, result -> {
                Log.d(TAG, "Finish capture got result: " + result);
            });
        });
    }

    private void setTimestamp(Long timestamp) {
        this.timestamp = timestamp;
    }

    private void showError(CharSequence text) {
        Log.e(TAG, "Error: " + text);
        Handler mainHandler = new Handler(Looper.getMainLooper());
        mainHandler.post(() -> Toast.makeText(requireContext(), text, Toast.LENGTH_SHORT).show());
    }

    private void showMessage(CharSequence text) {
        Log.d(TAG, (String) text);
        Handler mainHandler = new Handler(Looper.getMainLooper());
        mainHandler.post(() -> Toast.makeText(requireContext(), text, Toast.LENGTH_SHORT).show());
    }

    private String getCertificate() {
        return "research";
    }

    private class RawDataFile {
        final Cast cast;

        RawDataFile(Cast cast) {
            this.cast = cast;
        }

        void requestResultRetrieved(int result) {
            if (result > 0) {
                showMessage("Found raw data");
                cast.readRawData(this::rawDataRetrieved);
            } else {
                showMessage("Failed to request raw data, ensure raw data buffering is enabled and image is frozen");
            }
        }

        void rawDataRetrieved(int result, ByteBuffer data) {
            if (result > 0) {
                try {
                    showMessage("Saving raw data");
                    Uri uri = IOUtils.saveInDocuments(data, "cast_raw_data", requireContext());
                    showMessage("Saved raw data in file " + uri);
                } catch (IOException e) {
                    showError(e.toString());
                }
            } else {
                showError("Could not retrieve raw data");
            }
        }
    }
}



================================================
FILE: examples/cast_android/app/src/main/java/me/clarius/sdk/cast/example/ImageConverter.java
================================================
package me.clarius.sdk.cast.example;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;

import java.nio.ByteBuffer;
import java.util.concurrent.Executor;

import me.clarius.sdk.ImageFormat;
import me.clarius.sdk.ProcessedImageInfo;

/**
 * Convert images in a separate thread to avoid blocking the producer (the SDK)
 */

public class ImageConverter {
    private final Executor executor;
    private final Callback callback;

    ImageConverter(Executor executor, Callback callback) {
        this.executor = executor;
        this.callback = callback;
    }

    public void convertImage(ByteBuffer buffer, ProcessedImageInfo info) {
        executor.execute(() -> {
            try {
                Bitmap bitmap = convert(buffer, info);
                callback.onResult(bitmap, info.tm);
            } catch (Exception e) {
                callback.onError(e);
            }
        });
    }

    private Bitmap convert(ByteBuffer buffer, ProcessedImageInfo info) {
        boolean isCompressed = info.format != ImageFormat.Uncompressed;
        Bitmap bitmap;
        if (isCompressed) {
            if (buffer.hasArray()) {
                byte[] bytes = buffer.array();
                int offset = buffer.arrayOffset();
                int length = info.imageSize;
                assert offset + length < bytes.length;
                bitmap = BitmapFactory.decodeByteArray(bytes, offset, length);
            } else {
                byte[] bytes = new byte[buffer.capacity()];
                buffer.get(bytes);
                bitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
            }
        } else {
            bitmap = Bitmap.createBitmap(info.width, info.height, Bitmap.Config.ARGB_8888);
            bitmap.copyPixelsFromBuffer(buffer);
        }
        if (bitmap == null)
            throw new AssertionError("bad image data");
        return bitmap;
    }

    interface Callback {
        void onResult(Bitmap bitmap, long timestamp);

        void onError(Exception e);
    }
}



================================================
FILE: examples/cast_android/app/src/main/java/me/clarius/sdk/cast/example/IOUtils.java
================================================
package me.clarius.sdk.cast.example;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.net.Uri;
import android.os.Build;
import android.provider.MediaStore;

import androidx.annotation.RequiresApi;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class IOUtils {
    @RequiresApi(api = Build.VERSION_CODES.Q)
    private static Uri save(ByteBuffer buffer, String prefix, Context context) throws IOException {
        final String fileName = String.format("%s_%s.tar", prefix,
                LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")));
        final ContentValues contentValues = new ContentValues();
        contentValues.put(MediaStore.MediaColumns.DISPLAY_NAME, fileName);
        contentValues.put(MediaStore.MediaColumns.MIME_TYPE, "application/x-tar");
        contentValues.put(MediaStore.MediaColumns.RELATIVE_PATH, "Documents/Clarius");
        final ContentResolver contentResolver = context.getContentResolver();
        final Uri uri = MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);
        final Uri itemUri = contentResolver.insert(uri, contentValues);
        if (itemUri == null) {
            throw new IOException("Failed to create the raw data file in the Documents folder");
        }
        try (OutputStream dest = contentResolver.openOutputStream(itemUri)) {
            dest.write(buffer.array());
        }
        return itemUri;
    }

    /**
     * Save the given byte buffer in the Documents folder.
     * <p>
     * NOTE: this method uses the MediaStore.Files.getContentUri() API which is only available on Android 10 and later.
     * Calling this method on older Android will raise an exception.
     *
     * @param buffer     the byte buffer to save.
     * @param context    the context to retrieve the Documents folder.
     * @return the saved file location.
     * @throws IOException
     */
    public static Uri saveInDocuments(ByteBuffer buffer, String prefix, Context context) throws IOException {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            return save(buffer, prefix, context);
        } else {
            throw new IOException("Saving only supported on Android 10 and later (API Q)");
        }
    }
}



================================================
FILE: examples/cast_android/app/src/main/java/me/clarius/sdk/cast/example/MainActivity.java
================================================
package me.clarius.sdk.cast.example;

import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;

import androidx.appcompat.app.AppCompatActivity;
import androidx.navigation.NavController;
import androidx.navigation.Navigation;
import androidx.navigation.ui.AppBarConfiguration;
import androidx.navigation.ui.NavigationUI;

import me.clarius.sdk.cast.example.databinding.ActivityMainBinding;

public class MainActivity extends AppCompatActivity {

    private AppBarConfiguration appBarConfiguration;
    private ActivityMainBinding binding;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        binding = ActivityMainBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        setSupportActionBar(binding.toolbar);

        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment_content_main);
        appBarConfiguration = new AppBarConfiguration.Builder(navController.getGraph()).build();
        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }

    @Override
    public boolean onSupportNavigateUp() {
        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment_content_main);
        return NavigationUI.navigateUp(navController, appBarConfiguration)
                || super.onSupportNavigateUp();
    }
}



================================================
FILE: examples/cast_android/app/src/main/java/me/clarius/sdk/cast/example/Utils.java
================================================
package me.clarius.sdk.cast.example;

import java.util.Optional;
import java.util.function.Function;

public class Utils {
    /**
     * Convert a string to an integer.
     *
     * @param from      input string.
     * @param transform a conversion function, for example Long::parseLong.
     * @param <T>       the integer type, for example Long.
     * @return the converted integer or an empty optional if the conversion failed.
     */
    static <T> Optional<T> maybeInteger(final CharSequence from, Function<String, T> transform) {
        try {
            final String fromString = String.valueOf(from);
            final T ret = transform.apply(fromString);
            return Optional.of(ret);
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }

    /**
     * Convert a string to a long.
     *
     * @param from input string.
     * @return the converted long or an empty optional if the conversion failed.
     */
    static Optional<Long> maybeLong(final CharSequence from) {
        return maybeInteger(from, Long::parseLong);
    }

    /**
     * Convert a string to an int.
     *
     * @param from input string.
     * @return the converted int or an empty optional if the conversion failed.
     */
    static Optional<Integer> maybeInt(final CharSequence from) {
        return maybeInteger(from, Integer::parseInt);
    }
}



================================================
FILE: examples/cast_android/app/src/main/res/drawable/ic_baseline_image.xml
================================================
<vector android:height="24dp" android:tint="#000000"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="@android:color/white" android:pathData="M21,19V5c0,-1.1 -0.9,-2 -2,-2H5c-1.1,0 -2,0.9 -2,2v14c0,1.1 0.9,2 2,2h14c1.1,0 2,-0.9 2,-2zM8.5,13.5l2.5,3.01L14.5,12l4.5,6H5l3.5,-4.5z"/>
</vector>



================================================
FILE: examples/cast_android/app/src/main/res/drawable/ic_launcher_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path
        android:fillColor="#3DDC84"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeWidth="0.8"
        android:strokeColor="#33FFFFFF" />
</vector>



================================================
FILE: examples/cast_android/app/src/main/res/drawable/ic_launcher_foreground.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
        android:strokeWidth="1"
        android:strokeColor="#00000000" />
</vector>



================================================
FILE: examples/cast_android/app/src/main/res/layout/activity_main.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <com.google.android.material.appbar.AppBarLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:theme="@style/Theme.CastExample.AppBarOverlay">

        <androidx.appcompat.widget.Toolbar
            android:id="@+id/toolbar"
            android:layout_width="match_parent"
            android:layout_height="?attr/actionBarSize"
            android:background="?attr/colorPrimary"
            app:popupTheme="@style/Theme.CastExample.PopupOverlay" />

    </com.google.android.material.appbar.AppBarLayout>

    <include layout="@layout/content_main" />

</androidx.coordinatorlayout.widget.CoordinatorLayout>



================================================
FILE: examples/cast_android/app/src/main/res/layout/content_main.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layout_behavior="@string/appbar_scrolling_view_behavior">

    <fragment
        android:id="@+id/nav_host_fragment_content_main"
        android:name="androidx.navigation.fragment.NavHostFragment"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:defaultNavHost="true"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:navGraph="@navigation/nav_graph" />
</androidx.constraintlayout.widget.ConstraintLayout>



================================================
FILE: examples/cast_android/app/src/main/res/layout/fragment_first.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".FirstFragment">

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/connection_layout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent">

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/ip_address_layout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/ip_address"
            app:errorEnabled="true"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/ip_address"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="text"
                android:maxLines="1"
                android:text="@string/default_ip_address" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/tcp_port_layout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/tcp_port"
            app:errorEnabled="true"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/ip_address_layout">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/tcp_port"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="number"
                android:text="@string/default_tcp_port" />
        </com.google.android.material.textfield.TextInputLayout>

        <com.google.android.material.textfield.TextInputLayout
            android:id="@+id/network_id_layout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="@string/network_id"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/tcp_port_layout">

            <com.google.android.material.textfield.TextInputEditText
                android:id="@+id/network_id"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:inputType="number" />
        </com.google.android.material.textfield.TextInputLayout>

        <Button
            android:id="@+id/button_connect"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/connect" />

        <Button
            android:id="@+id/button_disconnect"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/disconnect" />

        <androidx.constraintlayout.helper.widget.Flow
            android:id="@+id/connection_layout_flow"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:constraint_referenced_ids="button_connect,button_disconnect"
            app:flow_wrapMode="aligned"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toBottomOf="@+id/network_id_layout" />
    </androidx.constraintlayout.widget.ConstraintLayout>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:id="@+id/control_layout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/connection_layout">

        <Button
            android:id="@+id/button_run"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/toggle_run" />

        <Button
            android:id="@+id/button_capture"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/capture_image" />

        <Button
            android:id="@+id/button_raw_data"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/get_raw_data" />

        <androidx.constraintlayout.helper.widget.Flow
            android:id="@+id/control_layout_flow"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:constraint_referenced_ids="button_run,button_capture,button_raw_data"
            app:flow_wrapMode="aligned"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintStart_toStartOf="parent"
            app:layout_constraintTop_toTopOf="parent" />

    </androidx.constraintlayout.widget.ConstraintLayout>

    <ProgressBar
        android:id="@+id/raw_data_download_progress_bar"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="100"
        android:min="0"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/control_layout" />

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_gravity="center"
        android:contentDescription="@string/ultrasound_image"
        android:src="@drawable/ic_baseline_image"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/raw_data_download_progress_bar" />

</androidx.constraintlayout.widget.ConstraintLayout>



================================================
FILE: examples/cast_android/app/src/main/res/menu/menu_main.xml
================================================
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:context="me.clarius.sdk.cast.example.MainActivity">
    <item
        android:id="@+id/action_settings"
        android:orderInCategory="100"
        android:title="@string/action_settings"
        app:showAsAction="never" />
</menu>



================================================
FILE: examples/cast_android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>



================================================
FILE: examples/cast_android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>



================================================
FILE: examples/cast_android/app/src/main/res/mipmap-hdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-hdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-mdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-mdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-xhdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-xhdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-xxhdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-xxxhdpi/ic_launcher.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.webp
================================================
[Binary file]


================================================
FILE: examples/cast_android/app/src/main/res/navigation/nav_graph.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/nav_graph"
    app:startDestination="@id/FirstFragment">

    <fragment
        android:id="@+id/FirstFragment"
        android:name="me.clarius.sdk.cast.example.FirstFragment"
        android:label="@string/first_fragment_label"
        tools:layout="@layout/fragment_first"/>
</navigation>



================================================
FILE: examples/cast_android/app/src/main/res/values/colors.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/values/dimens.xml
================================================
<resources>
    <dimen name="fab_margin">16dp</dimen>
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/values/strings.xml
================================================
<resources>
    <string name="app_name">Cast Example</string>
    <string name="action_settings">Settings</string>
    <!-- Strings used for fragments for navigation -->
    <string name="first_fragment_label">First Fragment</string>
    <string name="second_fragment_label">Second Fragment</string>
    <string name="next">Next</string>
    <string name="previous">Previous</string>

    <string name="hello_first_fragment">Hello first fragment</string>
    <string name="hello_second_fragment">Hello second fragment. Arg: %1$s</string>
    <string name="bluetooth">Bluetooth</string>
    <string name="default_ip_address">192.168.1.1</string>
    <string name="tcp_port">TCP port</string>
    <string name="default_tcp_port">5828</string>
    <string name="connect">Connect</string>
    <string name="disconnect">Disconnect</string>
    <string name="toggle_run">Toggle run</string>
    <string name="capture_image">Capture image</string>
    <string name="ask_state">Ask state</string>
    <string name="ultrasound_image">Ultrasound image</string>
    <string name="get_raw_data">Get raw data</string>
    <string name="ip_address">IP address</string>
    <string name="network_id">Network ID</string>
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/values/themes.xml
================================================
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.CastExample" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_500</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/white</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_700</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>

    <style name="Theme.CastExample.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
    </style>

    <style name="Theme.CastExample.AppBarOverlay" parent="ThemeOverlay.AppCompat.Dark.ActionBar" />

    <style name="Theme.CastExample.PopupOverlay" parent="ThemeOverlay.AppCompat.Light" />
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/values-land/dimens.xml
================================================
<resources>
    <dimen name="fab_margin">48dp</dimen>
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/values-night/themes.xml
================================================
<resources xmlns:tools="http://schemas.android.com/tools">
    <!-- Base application theme. -->
    <style name="Theme.CastExample" parent="Theme.MaterialComponents.DayNight.DarkActionBar">
        <!-- Primary brand color. -->
        <item name="colorPrimary">@color/purple_200</item>
        <item name="colorPrimaryVariant">@color/purple_700</item>
        <item name="colorOnPrimary">@color/black</item>
        <!-- Secondary brand color. -->
        <item name="colorSecondary">@color/teal_200</item>
        <item name="colorSecondaryVariant">@color/teal_200</item>
        <item name="colorOnSecondary">@color/black</item>
        <!-- Status bar color. -->
        <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>
        <!-- Customize your theme here. -->
    </style>
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/values-w1240dp/dimens.xml
================================================
<resources>
    <dimen name="fab_margin">200dp</dimen>
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/values-w600dp/dimens.xml
================================================
<resources>
    <dimen name="fab_margin">48dp</dimen>
</resources>



================================================
FILE: examples/cast_android/app/src/main/res/xml/backup_rules.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
   Sample backup rules file; uncomment and customize as necessary.
   See https://developer.android.com/guide/topics/data/autobackup
   for details.
   Note: This file is ignored for devices older that API 31
   See https://developer.android.com/about/versions/12/backup-restore
-->
<full-backup-content>
    <!--
   <include domain="sharedpref" path="."/>
   <exclude domain="sharedpref" path="device.xml"/>
-->
</full-backup-content>



================================================
FILE: examples/cast_android/app/src/main/res/xml/data_extraction_rules.xml
================================================
<?xml version="1.0" encoding="utf-8"?><!--
   Sample data extraction rules file; uncomment and customize as necessary.
   See https://developer.android.com/about/versions/12/backup-restore#xml-changes
   for details.
-->
<data-extraction-rules>
    <cloud-backup>
        <!-- TODO: Use <include> and <exclude> to control what is backed up.
        <include .../>
        <exclude .../>
        -->
    </cloud-backup>
    <!--
    <device-transfer>
        <include .../>
        <exclude .../>
    </device-transfer>
    -->
</data-extraction-rules>



================================================
FILE: examples/cast_android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



================================================
FILE: examples/cast_split/CaptureLabel.swift
================================================
//
//  CaptureLabel.swift
//  SideBySide
//

import SwiftUI

struct CaptureLabel {
    var text: String
    var position: CGPoint
}



================================================
FILE: examples/cast_split/CastModel.swift
================================================
//
//  CastModel.swift
//  Cast Example
//
//  Class to wrap the Cast framework for Swift
//

import Foundation
import CoreGraphics

/// Class to wrap the Cast framework for Swift
class CastModel: ObservableObject {

    /// Last image received from the scanner
    @Published var image: CGImage?
    /// The frozen state of the connected scanner
    @Published var frozen: Bool = true

    /// Scanner's IP address
    @Published var address: String = ""
    /// Scanner's TCP port
    @Published var port: UInt32 = 0
    /// Certificate to allow scanner use (provide before connecting)
    @Published var certificate: String = "research"

    var lastTime: Int64 = 0

    private let size: CGSize = CGSize(width: 800, height: 800)

    /// Connect to the scanner at the given address and port
    func connectToScanner() {
        cast.connect(address, port: port, cert: certificate) { (succeeded: Bool, imagePort: Int32, imuPort: Int32, swRevMatch: Bool) -> Void in
            print("Connection to \(self.address):\(self.port) \(succeeded ? "succeeded" : "failed")")
            if (succeeded) {
                print("Image UDP stream will be on port \(imagePort)")
                print("IMU UDP stream will be on port \(imuPort)")
                print("App software \(swRevMatch ? "matches" : "does not match")")
            }
        }
    }
    /// Disconnect from the current scanner
    func disconnect() {
        cast.disconnect() {
            print("Disconnection \($0 ? "succeeded" : "failed")")
        }
    }
    /// Send a freeze toggle command to the connected scanner
    func toggleFreeze() {
        cast.userFunction(Freeze, value: 0.0, callback: {
            print("User function freeze \($0 ? "succeeded" : "failed")")
        })
    }
    /// Send a create capture command
    func createCapture(labels: [CaptureLabel], measurements: [Measurement]) {
        if (lastTime == 0) {
            print("Cannot capture, no image received from scanner")
            return
        }
        cast.startCapture(lastTime) { (captureID: Int32) -> Void in
            if (captureID < 0) {
                print("Failed to start capture")
                return
            }
            for label in labels {
                let position = label.position * self.size;
                self.cast.addLabelOverlay(captureID, text: label.text, x: position.x, y: position.y, width: self.size.width, height: self.size.height)
            }
            for measurement in measurements {
                var scaled: [CGPoint] = []
                scaled.append(measurement.position1 * self.size)
                scaled.append(measurement.position2 * self.size)
                self.cast.addMeasurement(captureID, type: CusMeasurementTypeDistance, label: measurement.text, points: scaled)
            }
            self.cast.finishCapture(captureID) { (result: Bool) -> Void in
                if (result) {
                    print("Created capture successfully")
                } else {
                    print("Failed to finish capture")
                }
            }
        }
    }
    /// Framework instance
    private let cast = CusCast()
    /// Initialize the framework and register for callbacks
    init() {
        cast.setErrorCallback({ (errorString: String) -> Void in
            print(errorString)
        })
        // The framework requires a directory for storing security keys.
        // Using the application support path for this application.
        let appSupportPaths = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)
        let appSupportPath = appSupportPaths[0].path
        cast.initialize(appSupportPath) { (result: Bool) -> Void in
            print("Initialization \(result ? "succeeded" : "failed")")
        }
        cast.setOutputWidth(Int32(size.width), withHeight: Int32(size.height))
        cast.setFreezeCallback({ (frozen: Bool) -> Void in
            self.frozen = frozen
        })
        cast.setNewProcessedImageCallback({ (imageData: Data, imageInfo: UnsafePointer<CusProcessedImageInfo>, npos: Int32, positions: UnsafePointer<CusPosInfo>) -> Void in
            // Converting the raw image data into a CGImage which can be displayed
            let nfo = imageInfo.pointee
            let rowBytes = nfo.width * nfo.bitsPerPixel / 8
            let totalBytes = Int(nfo.height * rowBytes)
            let rawBytes = UnsafeMutableRawPointer.allocate(byteCount: totalBytes, alignment: 1)
            defer {
                rawBytes.deallocate()
            }
            let bmpInfo = CGImageAlphaInfo.premultipliedFirst.rawValue | CGBitmapInfo.byteOrder32Little.rawValue
            imageData.copyBytes(to: UnsafeMutableRawBufferPointer(start: rawBytes, count: totalBytes))
            guard let colorspace = CGColorSpace(name: CGColorSpace.sRGB) else {
                return
            }
            guard let ctxt = CGContext(data: rawBytes, width: Int(nfo.width), height: Int(nfo.height), bitsPerComponent: 8, bytesPerRow: Int(rowBytes), space: colorspace, bitmapInfo: bmpInfo) else {
                return
            }
            self.lastTime = nfo.tm
            self.image = ctxt.makeImage()
        })
        // Listen for notifications from the scanners model about scanner details
        NotificationCenter.default.addObserver(forName: .scannerDetails, object: nil, queue: nil) { [weak self] notification in
           guard let self = self else {
               return
           }
           guard let userInfo = notification.userInfo else {
               return
           }
           guard let scanner = userInfo["scanner"] as? Scanner else {
               return
           }
           self.address = scanner.ip
           self.port = scanner.tcpPort
       }
    }
}



================================================
FILE: examples/cast_split/ContentView.swift
================================================
//
//  ContentView.swift
//  SideBySide
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject private var cast: CastModel
    @State private var labelToAdd: String = ""
    @State private var labels: [CaptureLabel] = []
    @State private var measurements: [Measurement] = []
    @State private var imagingSize: CGSize = .zero
    @State private var imagingPosition: CGPoint = .zero
    func labelPos(_ measurement: Measurement) -> CGPoint {
        let center = (measurement.position1 + measurement.position2) / 2
        return center * imagingSize + imagingPosition
    }
    func displayImage() -> Image {
        if cast.image != nil {
            return Image(cast.image!, scale: 1.0, label: Text("Ultrasound"))
        } else {
            return Image("BlankImage")
        }
    }
    func imageView(_ geometry: GeometryProxy) -> some View {
        DispatchQueue.main.async {
            let dimension = min(geometry.size.width, geometry.size.height)
            self.imagingSize = CGSize(width: dimension, height: dimension)
            self.imagingPosition = CGPoint(x: (geometry.size.width - dimension) / 2, y: (geometry.size.height - dimension) / 2)
        }
        return displayImage()
                .resizable()
    }
    struct Cursor: View {
        var body: some View {
            ZStack {
                Rectangle()
                    .opacity(0.0001)
                GeometryReader { geometry in
                    Path { path in
                        let frame = geometry.frame(in: .local)
                        let strokeY = frame.height / 4
                        path.move(to: CGPoint(x: frame.midX, y: frame.minY))
                        path.addLine(to: CGPoint(x: frame.midX, y: frame.minY + strokeY))
                        path.move(to: CGPoint(x: frame.midX, y: frame.maxY - strokeY))
                        path.addLine(to: CGPoint(x: frame.midX, y: frame.maxY))
                        let strokeX = frame.width / 4
                        path.move(to: CGPoint(x: frame.minX, y: frame.midY))
                        path.addLine(to: CGPoint(x: frame.minX + strokeX, y: frame.midY))
                        path.move(to: CGPoint(x: frame.maxX - strokeX, y: frame.midY))
                        path.addLine(to: CGPoint(x: frame.maxX, y: frame.midY))
                    }.stroke(.green, style: StrokeStyle(lineWidth: 1))
                }
            }
        }
    }
    var body: some View {
        ScrollView {
            VStack {
                GroupBox(label: Label("Wi-Fi", systemImage: "wifi").font(.title3)) {
                    VStack {
                        HStack {
                            Text("IP Address")
                            TextField("IP Address", text: $cast.address)
                        }
                        HStack {
                            Text("Port")
                            TextField("Port", value: $cast.port, format: .number)
                        }
                        HStack {
                            Text("Certificate")
                            TextField("Certificate", text: $cast.certificate)
                        }
                        HStack {
                            Button(action: cast.connectToScanner) {
                                Text("Connect")
                            }
                            Button(action: cast.disconnect) {
                                Text("Disconnect")
                            }
                        }
                    }
                }.padding()
                GroupBox(label: Label("Capture", systemImage: "camera").font(.title3)) {
                    VStack {
                        HStack {
                            Button(action: {
                                labels = []
                                measurements = []
                            }) {
                                Text("Clear Screen")
                            }
                            Button(action: {
                                let mmtLabel = "D\(measurements.count + 1)"
                                measurements.append(Measurement(text: mmtLabel, position1: CGPoint(x: 0.4, y: 0.4), position2: CGPoint(x: 0.6, y: 0.6)))
                            }) {
                                Text("Add Measurement")
                            }
                            Button(action: {
                                cast.createCapture(labels: self.labels, measurements: self.measurements)
                            }) {
                                Text("Create Capture")
                            }
                        }
                        HStack {
                            TextField("Text", text: $labelToAdd)
                            Button(action: {
                                if labelToAdd.isEmpty {
                                    print("No label text provided")
                                    return
                                }
                                labels.append(CaptureLabel(text: labelToAdd, position: CGPoint(x: 0.5, y: 0.5)))
                            }) {
                                Text("Add Label")
                            }
                        }
                    }
                }.padding()
                GroupBox(label: Label("Imaging", systemImage: "waveform").font(.title3)) {
                    HStack {
                        Button(action: cast.toggleFreeze) {
                            Text("Toggle Freeze")
                        }
                        Text("Imaging is \(cast.frozen ? "frozen" : "live")")
                            .frame(maxWidth: .infinity)
                    }
                    GeometryReader { geometry in
                        ZStack(alignment: .center) {
                            self.imageView(geometry)
                            ForEach(Array(zip(measurements.indices, measurements)), id: \.0) { index, measurement in
                                Path { path in
                                    path.move(to: measurement.position1 * imagingSize + imagingPosition)
                                    path.addLine(to: measurement.position2 * imagingSize + imagingPosition)
                                }.stroke(.green, style: StrokeStyle(lineWidth: 1, dash: [imagingSize.height / 80, imagingSize.height / 80]))
                                Text(measurement.text)
                                    .position(labelPos(measurement))
                                Cursor()
                                    .frame(width: imagingSize.height / 20, height: imagingSize.height / 20)
                                    .position(measurement.position1 * imagingSize + imagingPosition)
                                    .gesture(DragGesture().onChanged{ state in
                                        measurements[index].position1 = (state.location - imagingPosition) / imagingSize
                                    })
                                Cursor()
                                    .frame(width: imagingSize.height / 20, height: imagingSize.height / 20)
                                    .position(measurement.position2 * imagingSize + imagingPosition)
                                    .gesture(DragGesture().onChanged{ state in
                                        measurements[index].position2 = (state.location - imagingPosition) / imagingSize
                                    })
                            }
                            ForEach(Array(zip(labels.indices, labels)), id: \.0) { index, label in
                                Text(label.text)
                                    .position(label.position * imagingSize + imagingPosition)
                                    .gesture(DragGesture().onChanged{ state in
                                        labels[index].position = (state.location - imagingPosition) / imagingSize
                                    })
                            }
                        }
                    }.aspectRatio(1, contentMode: .fit)

                }.padding()
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(CastModel())
    }
}



================================================
FILE: examples/cast_split/iOS-Bridging-Header.h
================================================
//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//

#import <cast_framework/cast.h>



================================================
FILE: examples/cast_split/macOS-Bridging-Header.h
================================================
//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//

#import <cast_framework/cast.h>



================================================
FILE: examples/cast_split/Measurement.swift
================================================
//
//  Measurement.swift
//  SideBySide
//

import SwiftUI

struct Measurement {
    var text: String
    var position1: CGPoint
    var position2: CGPoint
}



================================================
FILE: examples/cast_split/Operations.swift
================================================
//
//  Operations.swift
//  SideBySide
//

import SwiftUI

func +(lhs: CGPoint, rhs: CGPoint) -> CGPoint {
    return CGPoint(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
}
func -(lhs: CGPoint, rhs: CGPoint) -> CGPoint {
    return CGPoint(x: lhs.x - rhs.x, y: lhs.y - rhs.y)
}
func /(lhs: CGPoint, rhs: CGFloat) -> CGPoint {
    return CGPoint(x: lhs.x / rhs, y: lhs.y / rhs)
}
func *(lhs: CGPoint, rhs: CGSize) -> CGPoint {
    return CGPoint(x: lhs.x * rhs.width, y: lhs.y * rhs.height)
}
func /(lhs: CGPoint, rhs: CGSize) -> CGPoint {
    return CGPoint(x: lhs.x / rhs.width, y: lhs.y / rhs.height)
}



================================================
FILE: examples/cast_split/Scanner.swift
================================================
//
//  Scanner.swift
//  Solum Example
//
//  Clarius scanner details
//

import Foundation

/// Clarius scanner details
struct Scanner: Identifiable {
    /// Serial number
    var serial: String
    /// Scanner's IP address (v4 or v6)
    var ip: String
    /// Scanner's TCP port for control connections
    var tcpPort: UInt32
    /// ID provided for use in collections
    var id: String { serial }
}



================================================
FILE: examples/cast_split/SideBySide-Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>CFBundleURLName</key>
			<string>com.clarius.sidebyside</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>com.clarius.sidebyside</string>
			</array>
		</dict>
	</array>
	<key>UIApplicationSceneManifest</key>
	<false/>
	<key>UILaunchScreen</key>
	<true/>
</dict>
</plist>



================================================
FILE: examples/cast_split/SideBySide.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <true/>
    <key>com.apple.security.files.user-selected.read-only</key>
    <true/>
	<key>com.apple.security.network.client</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
FILE: examples/cast_split/SideBySideApp.swift
================================================
//
//  SideBySideApp.swift
//  SideBySide
//

import SwiftUI

extension Notification.Name {
    /// Notification that the scanner details should be should populated, user data: "scanner" as Scanner struct
    static let scannerDetails = Notification.Name("scannerDetails")
}

func parseScanner(url: URL) -> Scanner? {
    guard let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
        return nil
    }
    guard let queryItems = components.queryItems else {
        return nil
    }
    var ipAddress: String?
    var serial: String?
    var tcpPort: UInt32?
    for item in queryItems {
        switch (item.name) {
        case "serial":
            serial = item.value
        case "address":
            ipAddress = item.value
        case "port":
            tcpPort = UInt32(item.value ?? "")
        default:
            print("Unknown parameter \(item.name)")
        }
    }
    guard let serial = serial, let ipAddress = ipAddress, let tcpPort = tcpPort else {
        return nil
    }
    return Scanner(serial: serial, ip: ipAddress, tcpPort: tcpPort)
}

@main
struct SideBySideApp: App {
    @StateObject private var castModel = CastModel()
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(castModel)
                .onOpenURL { url in
                    guard let scanner = parseScanner(url: url) else {
                        return
                    }
                    let userInfo = ["scanner": scanner]
                    NotificationCenter.default.post(name: .scannerDetails, object: nil, userInfo: userInfo)
                }
        }
    }
}



================================================
FILE: examples/cast_split/Assets.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/cast_split/Assets.xcassets/AccentColor.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/cast_split/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "512x512"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "512x512"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/cast_split/Assets.xcassets/BlankImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "black.jpeg",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/cast_split/ios/Launch Screen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Llm-lL-Icb"/>
                        <viewControllerLayoutGuide type="bottom" id="xb3-aO-Qok"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" red="0.070588235294117647" green="0.070588235294117647" blue="0.070588235294117647" alpha="1" colorSpace="calibratedRGB"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>



================================================
FILE: examples/cast_split/ios/plist.in
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>${MACOSX_BUNDLE_EXECUTABLE_NAME}</string>
	<key>CFBundleGetInfoString</key>
	<string>${MACOSX_BUNDLE_INFO_STRING}</string>
	<key>CFBundleIdentifier</key>
	<string>${MACOSX_BUNDLE_GUI_IDENTIFIER}</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleLongVersionString</key>
	<string>${MACOSX_BUNDLE_LONG_VERSION_STRING}</string>
	<key>CFBundleName</key>
	<string>${MACOSX_BUNDLE_BUNDLE_NAME}</string>
	<key>CFBundleDisplayName</key>
	<string>${MACOSX_BUNDLE_BUNDLE_NAME}</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>${MACOSX_BUNDLE_SHORT_VERSION_STRING}</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>${MACOSX_BUNDLE_BUNDLE_VERSION}</string>
	<key>CSResourcesFileMapped</key>
	<true/>
	<key>LSRequiresCarbon</key>
	<true/>
	<key>NSHumanReadableCopyright</key>
	<string>Copyright © 2016-@COPYRIGHT_YEAR@ Clarius Mobile Health Corp. All Rights Reserved.</string>
	<key>UILaunchStoryboardName</key>
	<string>Launch Screen</string>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>CFBundleURLName</key>
			<string>com.clarius.sidebyside</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>com.clarius.sidebyside</string>
			</array>
		</dict>
	</array>
	<key>UIApplicationSceneManifest</key>
	<false/>
	<key>UILaunchScreen</key>
	<true/>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>



================================================
FILE: examples/cast_split/SideBySide (MacOS)/SideBySide__MacOS_.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.files.user-selected.read-only</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
FILE: examples/cast_swift/Cast-Example--iOS--Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>



================================================
FILE: examples/cast_swift/Cast-Example--macOS--Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>



================================================
FILE: examples/cast_swift/macOS/macOS.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.device.bluetooth</key>
	<true/>
	<key>com.apple.security.files.user-selected.read-only</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
FILE: examples/cast_swift/Shared/BluetoothModel.swift
================================================
//
//  Bluetooth.swift
//  Solum Example
//
//  Class for finding scanners over bluetooth
//

import Foundation
import CoreBluetooth
import Yams

/// Holder for UUIDs relevant to the Wi-Fi info service
struct WifiService {
    /// The UUID for the service itself
    public static let serviceUUID = CBUUID.init(string: "f9eb3fae-947a-4e5b-ab7c-c799e91ed780")
    /// Characteristic for reading the value (read/subscribe)
    public static let infoCharacteristic = CBUUID.init(string: "f9eb3fae-947a-4e5b-ab7c-c799e91ed781")
}

/// Holder for UUIDs relevant to the power service
struct PowerService {
    /// The UUID for the service itself
    public static let serviceUUID = CBUUID.init(string: "8c853b6a-2297-44c1-8277-73627c8d2abc")
    /// Characteristic for reading the value (read/subscribe)
    public static let infoCharacteristic = CBUUID.init(string: "8c853b6a-2297-44c1-8277-73627c8d2abd")
}

/// Details about a scanner found over bluetooth
struct DeviceFound {
    /// Serial number
    var serial: String
    /// Battery level in 0-100%
    var battery: Int
    /// Temperature in degrees Celsius
    var temperature: Int
    /// Turn if currently powered on
    var powered: Bool
    /// Current availability
    var availability: Availability
    /// Listen policy (for Clarius Cast)
    var listenPolicy: ListenPolicy
    /// Charging status
    var chargingStatus: ChargingStatus
    /// Bluetooth RSSI
    var rssi: Int
}

/// Try to parse out the serial number of a bluetooth peripheral
/// - Parameter peripheral: Bluetooth peripheral discovered during a scan
/// - Returns: The serial number if the device is a Clarius scanner, otherwise nil
func serialForDevice(peripheral: CBPeripheral) -> String? {
    guard let deviceName = peripheral.name else {
        return nil
    }
    if !deviceName.starts(with: "CUS-") {
        return nil
    }
    return String(deviceName.dropFirst(4))
}

/// Parse out the scanner details from a bluetooth device
/// - Parameters:
///   - peripheral: Bluetooth peripheral discovered during a scan
///   - advertisementData: Data advertised over BLE
///   - rssi: Bluetooth RSSI
/// - Returns: Device details if the given peripheral is a Clarius scanner, otherwise nil
func parseDevice(peripheral: CBPeripheral, advertisementData: [String : Any], rssi: Int) -> DeviceFound? {
    guard let serial = serialForDevice(peripheral: peripheral) else {
        return nil
    }
    guard let manufacturerAny = advertisementData[CBAdvertisementDataManufacturerDataKey] else {
        return nil
    }
    guard let manufacturerData = manufacturerAny as? NSData else {
        return nil
    }
    if manufacturerData.length < 6 {
        return nil
    }
    // The first 2 bytes are just to identify Clarius
    if manufacturerData[0] != 0xFB || manufacturerData[1] != 0x02 {
        return nil
    }
    let batt = min(Int(manufacturerData[2]), 100)
    let temp = min(Int(manufacturerData[3]), 100)
    let packedBits = Int(manufacturerData[4])
    guard let avail = Availability(rawValue: min(packedBits & 0x07, Availability.allCases.count)) else { return nil
    }
    guard let listen = ListenPolicy(rawValue: min((packedBits >> 3) & 0x03, ListenPolicy.allCases.count)) else {
        return nil
    }
    guard let charging = ChargingStatus(rawValue: min((packedBits >> 6) & 0x03, ChargingStatus.allCases.count)) else {
        return nil
    }
    let powered = (Int(manufacturerData[5]) & 0x01) != 0;
    return DeviceFound(serial: serial, battery: batt, temperature: temp, powered: powered, availability: avail, listenPolicy: listen, chargingStatus: charging, rssi: rssi)
}

/// Wi-Fi information which is delivered over Bluetooth
struct WifiInfo {
    /// SSID of the scanner's current Wi-Fi network
    var ssid: String
    /// Password of the scanner's current Wi-Fi network (if Wi-Fi direct)
    var password: String
    /// Scanner's IP address (v4 or v6)
    var ip: String
    /// Scanner's TCP port for control connections
    var port: UInt32
}

/// Parse Wi-Fi info that is received from the scanner
/// - Parameter value: Data which was read over bluetooth
/// - Returns: The parsed Wi-Fi info, if successful
func parseWifiInfo(value: Data) -> WifiInfo? {
    guard let dataString = String(data: value, encoding: .utf8) else {
        return nil
    }
    print("WifiInfo received: \(dataString)")
    guard let object = try? Yams.load(yaml: dataString) else {
        return nil
    }
    guard let mapped = object as? [String: Any] else {
        return nil
    }
    // All of these are technically optional, but
    // the SSID and password should be provided for
    // Wi-Fi direct networks
    let ssid = mapped["ssid"] as? String
    let password = mapped["pw"] as? String
    let ipv4 = mapped["ip4"] as? String
    let ipv6 = mapped["ip6"] as? String
    // This is the TCP port which should be used for cast connections
    let port = mapped["cast"] as? Int
    let ip = ipv4 ?? ipv6 ?? ""
    return WifiInfo(ssid: ssid ?? "", password: password ?? "", ip: ip, port: UInt32(port ?? 0))
}

/// Class for finding scanners over bluetooth
class BluetoothModel: NSObject, ObservableObject, CBCentralManagerDelegate, CBPeripheralDelegate {
    /// Toggle to make the model continuously search for scanners
    @Published var scanActive: Bool = false  {
        didSet { checkScan() }
    }
    /// Serial of the scanner which we should connect to. Technically multiple
    /// simultaneous connections are possible, but it is simpler to only keep
    /// one connection active.
    @Published var selectedSerial: String = "" {
        didSet {
            if selectedSerial.isEmpty {
                return
            }
            guard let peripheral = peripherals[selectedSerial] else {
                return
            }
            centralManager.connect(peripheral)
        }
    }
    /// Cache of all Clarius scanners which have been found over Bluetooth
    private var peripherals: [String: CBPeripheral] = [:]
    /// Class for activating Bluetooth scans
    private var centralManager: CBCentralManager!
    /// True if the CBCentralManager is currently running a scan
    private var centralScanning = false
    /// Power state of local Bluetooth
    private var centralState = CBManagerState.unknown
    /// Initialize the CBCentralManager and subscribe for notifications
    override init() {
        super.init()
        // Bluetooth manager
        centralManager = CBCentralManager(delegate: self, queue: nil)
        // Listen for notifications from the scanner list about changing scanners
        NotificationCenter.default.addObserver(forName: .changeScanner, object: nil, queue: nil) { [weak self] notification in
            guard let self = self else {
                return
            }
            guard let userInfo = notification.userInfo else {
                return
            }
            guard let index = userInfo.index(forKey: "serial") else {
                return
            }
            guard let newSerial = userInfo[index].value as? String else {
                return
            }
            self.selectedSerial = newSerial
        }
    }
    /// Callback for CBCentralManager state notifications
    /// - Parameter central: CBCentralManager which is notifying
    internal func centralManagerDidUpdateState(_ central: CBCentralManager) {
        centralScanning = central.isScanning
        centralState = central.state
        checkScan()
    }
    /// Callback for device discovery notifications
    /// - Parameters:
    ///   - central: CBCentralManager
    ///   - peripheral: Device which was discovered
    ///   - advertisementData: Accompanying advertisement
    ///   - RSSI: Current signal strength
    internal func centralManager(_ central: CBCentralManager,
                        didDiscover peripheral: CBPeripheral,
                        advertisementData: [String : Any],
                        rssi RSSI: NSNumber) {
        // This also acts as a filter to ignore non-Clarius devices
        guard let deviceFound = parseDevice(peripheral: peripheral, advertisementData: advertisementData, rssi: RSSI.intValue) else {
            return
        }
        // Check if it is new device
        if peripherals.index(forKey: deviceFound.serial) == nil {
            // Tell it to give callbacks to us
            peripheral.delegate = self
            peripherals[deviceFound.serial] = peripheral
            // Connect if it is the selected scanner
            if selectedSerial == deviceFound.serial {
                centralManager.connect(peripheral)
            }
        }
        // Notify the other models that a scanner was found
        let userInfo = ["device": deviceFound]
        NotificationCenter.default.post(name: .deviceFound, object: nil, userInfo: userInfo)
    }
    /// Callback for successful device connection
    /// - Parameters:
    ///   - central: CBCentralManager
    ///   - peripheral: Device connected to
    internal func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        guard let serial = serialForDevice(peripheral: peripheral) else {
            return
        }
        // If it is still the selected scanner, discover its services
        if serial == selectedSerial {
            peripheral.discoverServices([PowerService.serviceUUID, WifiService.serviceUUID])
        }
    }
    /// Callback for device service discovery
    /// - Parameters:
    ///   - peripheral: Device with services discovered
    ///   - error: Error if a problem occurred
    internal func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
        if let error = error {
            print("Bluetooth error \(error.localizedDescription)")
            return
        }
        guard let serial = serialForDevice(peripheral: peripheral) else {
            return
        }
        // Check if it is still the selected scanner
        if serial != selectedSerial {
            return
        }
        guard let services = peripheral.services else {
            print("Scanner with serial \(serial) has no services")
            return
        }
        // Attempt to discover characteristics for any relevant services
        if let service = services.first(where: {$0.uuid == WifiService.serviceUUID}) {
            peripheral.discoverCharacteristics([WifiService.infoCharacteristic], for: service)
        }
        if let service = services.first(where: {$0.uuid == PowerService.serviceUUID}) {
            peripheral.discoverCharacteristics([PowerService.infoCharacteristic], for: service)
        }
    }
    /// Callback for characteristic discovery
    /// - Parameters:
    ///   - peripheral: Device which has the characteristic
    ///   - service: Service containing the characteristic
    ///   - error: Error, if one occurred
    internal func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        if let error = error {
            print("Bluetooth error \(error.localizedDescription)")
            return
        }
        guard let serial = serialForDevice(peripheral: peripheral) else {
            return
        }
        guard let characteristics = service.characteristics else {
            print("Scanner with serial \(serial) has no characteristics for \(service.uuid)")
            return
        }
        // Get the info characteristic for either the Wi-Fi service or the power service
        let uuid = service.uuid == WifiService.serviceUUID ? WifiService.infoCharacteristic : PowerService.infoCharacteristic
        guard let characteristic = characteristics.first(where: {$0.uuid == uuid}) else {
            return
        }
        // Try to register for notifications
        if characteristic.properties.contains(.notify) {
            peripheral.setNotifyValue(true, for: characteristic)
        }
        // Try to read the current value
        if characteristic.properties.contains(.read) {
            peripheral.readValue(for: characteristic)
        }
    }
    /// Callback for characteristic value updates
    /// - Parameters:
    ///   - peripheral: Device which has the characteristic
    ///   - characteristic: Characteristic with the updated value
    ///   - error: Error, if one occurred
    internal func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {

        if let error = error {
            print("Bluetooth error \(error.localizedDescription)")
            return
        }
        guard let serial = serialForDevice(peripheral: peripheral) else {
            return
        }
        guard let value = characteristic.value else {
            return
        }
        // If it is Wi-Fi info, attempt to parse
        if characteristic.uuid == WifiService.infoCharacteristic {
            guard let wifiInfo = parseWifiInfo(value: value) else {
                return
            }
            // Notify the other classes that Wi-Fi info was received
            let userInfo: [String: Any] = ["serial": serial,
                            "wifiInfo": wifiInfo]
            NotificationCenter.default.post(name: .wifiInfoReceived, object: nil, userInfo: userInfo)
        }
        // If it is power info, attempt to parse
        if characteristic.uuid == PowerService.infoCharacteristic {
            if value.count < 1 {
                return
            }
            let powered = (value[0] == 1)
            // Notify the other classes that the powered state was received
            let userInfo: [String: Any] = ["serial": serial,
                            "powered": powered]
            NotificationCenter.default.post(name: .poweredChanged, object: nil, userInfo: userInfo)
        }
    }
    /// Check if the bluetooth scan should be re-triggered
    private func checkScan() {
        if scanActive {
            if centralState == .poweredOn && !centralScanning {
                centralManager.scanForPeripherals(withServices: nil, options: [CBCentralManagerScanOptionAllowDuplicatesKey : true])
            }
        } else {
            if centralScanning {
                centralManager.stopScan()
            }
        }
    }
}



================================================
FILE: examples/cast_swift/Shared/Cast Example (iOS)-Bridging-Header.h
================================================
//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//

#import <cast_framework/cast.h>



================================================
FILE: examples/cast_swift/Shared/Cast Example (macOS)-Bridging-Header.h
================================================
//
//  Use this file to import your target's public headers that you would like to expose to Swift.
//

#import <cast_framework/cast.h>



================================================
FILE: examples/cast_swift/Shared/Cast_ExampleApp.swift
================================================
//
//  Cast_ExampleApp.swift
//  Shared
//
//  The main app which creates all class instances
//

import SwiftUI

extension Notification.Name {
    /// Notification that the selected scanner should change, user data: "serial" as String
    static let changeScanner = Notification.Name("changeScanner")
    /// Notification that a scanner was found over bluetooth, user data: "device" as DeviceFound struct
    static let deviceFound = Notification.Name("deviceFound")
    /// Notification that a scanner's powered state changed, user data: "serial" as String, "powered" as Bool
    static let poweredChanged = Notification.Name("poweredChanged")
    /// Notification that a scanner's Wi-Fi info changed, user data: "serial" as String, "wifiInfo" as WifiInfo struct
    static let wifiInfoReceived = Notification.Name("wifiInfoReceived")
    /// Notification that the scanner details should be should populated, user data: "scanner" as Scanner struct
    static let scannerDetails = Notification.Name("scannerDetails")
}

@main
/// The main app which creates all class instances
struct Cast_ExampleApp: App {
    @StateObject private var castModel = CastModel()
    @StateObject private var bluetooth = BluetoothModel()
    @StateObject private var scannersModel = ScannersModel()
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(castModel)
                .environmentObject(bluetooth)
                .environmentObject(scannersModel)
        }
    }
}



================================================
FILE: examples/cast_swift/Shared/CastModel.swift
================================================
//
//  CastModel.swift
//  Cast Example
//
//  Class to wrap the Cast framework for Swift
//

import Foundation
import CoreGraphics

/// Class to wrap the Cast framework for Swift
class CastModel: ObservableObject {

    /// Last image received from the scanner
    @Published var image: CGImage?
    /// The frozen state of the connected scanner
    @Published var frozen: Bool = true

    /// Scanner's SSID (informational)
    @Published var ssid: String = ""
    /// Scanner's Wi-Fi direct password (informational)
    @Published var password: String = ""
    /// Scanner's IP address
    @Published var address: String = ""
    /// Scanner's TCP port
    @Published var port: UInt32 = 0
    /// Certificate to allow scanner use (provide before connecting)
    @Published var certificate: String = "research"

    /// Connect to the scanner at the given address and port
    func connectToScanner() {
        cast.connect(address, port: port, cert: certificate) { (succeeded: Bool, port: Int32, imuPort: Int32, swRevMatch: Bool) -> Void in
            print("Connection to \(self.address):\(self.port) \(succeeded ? "succeeded" : "failed")")
            if (succeeded) {
                print("UDP stream will be on port \(port)")
                print("App software \(swRevMatch ? "matches" : "does not match")")
            }
        }
    }
    /// Disconnect from the current scanner
    func disconnect() {
        cast.disconnect() {
            print("Disconnection \($0 ? "succeeded" : "failed")")
        }
    }
    /// Send a freeze toggle command to the connected scanner
    func toggleFreeze() {
        cast.userFunction(Freeze, value: 0.0, callback: {
            print("User function freeze \($0 ? "succeeded" : "failed")")
        })
    }
    /// Framework instance
    private let cast = CusCast()
    /// Initialize the framework and register for callbacks
    init() {
        cast.setErrorCallback({ (errorString: String) -> Void in
            print(errorString)
        })
        // The framework requires a directory for storing security keys.
        // Using the application support path for this application.
        let appSupportPaths = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask)
        let appSupportPath = appSupportPaths[0].path
        cast.initialize(appSupportPath) { (result: Bool) -> Void in
            print("Initialization \(result ? "succeeded" : "failed")")
        }
        cast.setFreezeCallback({ (frozen: Bool) -> Void in
            self.frozen = frozen
        })
        cast.setNewProcessedImageCallback({ (imageData: Data, imageInfo: UnsafePointer<CusProcessedImageInfo>, npos: Int32, positions: UnsafePointer<CusPosInfo>) -> Void in
            // Converting the raw image data into a CGImage which can be displayed
            let nfo = imageInfo.pointee
            let rowBytes = nfo.width * nfo.bitsPerPixel / 8
            let totalBytes = Int(nfo.height * rowBytes)
            let rawBytes = UnsafeMutableRawPointer.allocate(byteCount: totalBytes, alignment: 1)
            defer {
                rawBytes.deallocate()
            }
            let bmpInfo = CGImageAlphaInfo.premultipliedFirst.rawValue | CGBitmapInfo.byteOrder32Little.rawValue
            imageData.copyBytes(to: UnsafeMutableRawBufferPointer(start: rawBytes, count: totalBytes))
            guard let colorspace = CGColorSpace(name: CGColorSpace.sRGB) else {
                return
            }
            guard let ctxt = CGContext(data: rawBytes, width: Int(nfo.width), height: Int(nfo.height), bitsPerComponent: 8, bytesPerRow: Int(rowBytes), space: colorspace, bitmapInfo: bmpInfo) else {
                return
            }
            self.image = ctxt.makeImage()
        })
        // Listen for notifications from the scanners model about scanner details
        NotificationCenter.default.addObserver(forName: .scannerDetails, object: nil, queue: nil) { [weak self] notification in
           guard let self = self else {
               return
           }
           guard let userInfo = notification.userInfo else {
               return
           }
           guard let scanner = userInfo["scanner"] as? Scanner else {
               return
           }
           self.ssid = scanner.ssid
           self.password = scanner.password
           self.address = scanner.ip
           self.port = scanner.tcpPort
       }
    }
}



================================================
FILE: examples/cast_swift/Shared/ContentView.swift
================================================
//
//  ContentView.swift
//  Shared
//
//  Main application view
//

import SwiftUI

struct ContentView: View {
    @EnvironmentObject private var cast: CastModel
    @EnvironmentObject private var bluetooth: BluetoothModel
    @EnvironmentObject private var scannerModel: ScannersModel
    func displayImage() -> Image {
        if cast.image != nil {
            return Image(cast.image!, scale: 1.0, label: Text("Ultrasound"))
        } else {
            return Image("BlankImage")
        }
    }
    var body: some View {
        ScrollView {
            VStack(spacing: 0) {
                GroupBox(label: Label("Bluetooth", systemImage: "antenna.radiowaves.left.and.right").font(.title3)) {
                    Toggle(isOn: $bluetooth.scanActive) {
                        Label("Searching", systemImage: "magnifyingglass")
                    }
                    ScannerList(scanners: scannerModel.scanners, selectedSerial: bluetooth.selectedSerial)
                    HStack {
                        Button(action: {
                            if bluetooth.selectedSerial.isEmpty {
                                print("Cannot load details when no scanner selected")
                                return
                            }
                            scannerModel.sendDetails(serial: bluetooth.selectedSerial)
                        }) {
                            Label("Load Selected Scanner Details", systemImage: "square.and.arrow.down.on.square")
                        }
                    }
                }.padding()
                GroupBox(label: Label("Wi-Fi", systemImage: "wifi").font(.title3)) {
                    VStack {
                        HStack {
                            Text("SSID")
                            TextField("SSID", text: $cast.ssid)
                        }
                        HStack {
                            Text("Password")
                            TextField("Password", text: $cast.password)
                        }
                        HStack {
                            Text("IP Address")
                            TextField("IP Address", text: $cast.address)
                        }
                        HStack {
                            Text("Port")
                            TextField("Port", value: $cast.port, format: .number)
                        }
                        HStack {
                            Text("Certificate")
                            TextField("Certificate", text: $cast.certificate)
                        }
                        HStack {
                            Button(action: cast.connectToScanner) {
                                Text("Connect")
                            }
                            Button(action: cast.disconnect) {
                                Text("Disconnect")
                            }
                        }
                    }
                }.padding()
                GroupBox(label: Label("Imaging", systemImage: "waveform").font(.title3)) {
                    VStack {
                        HStack {
                            Button(action: cast.toggleFreeze) {
                                Text("Toggle Freeze")
                            }
                            Text("Imaging is \(cast.frozen ? "frozen" : "live")")
                                .frame(maxWidth: .infinity)
                        }
                        displayImage()
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                        }
                }.padding()
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(CastModel())
            .environmentObject(BluetoothModel())
            .environmentObject(ScannersModel())
    }
}



================================================
FILE: examples/cast_swift/Shared/Scanner.swift
================================================
//
//  Scanner.swift
//  Solum Example
//
//  Clarius scanner details
//

import Foundation

/// Enumerations of scanner availabilities
enum Availability: Int, CaseIterable {
    case available = 0, listenOnly, notAvailable
}

/// Enumeration of scanner listen policies
enum ListenPolicy: Int, CaseIterable {
    case disabled = 0, institution, global, research
}

/// Enumeration of charging states
enum ChargingStatus: Int, CaseIterable {
    case none = 0, pre, fast, done
}

/// Clarius scanner details
struct Scanner: Identifiable {
    /// Serial number
    var serial: String
    /// SSID of the scanner's current Wi-Fi network
    var ssid: String
    /// Password of the scanner's current Wi-Fi network (if Wi-Fi direct)
    var password: String
    /// Scanner's IP address (v4 or v6)
    var ip: String
    /// Scanner's TCP port for control connections
    var tcpPort: UInt32
    /// Bluetooth RSSI
    var rssi: Int
    /// Battery level in 0-100%
    var battery: Int
    /// Temperature in degrees Celsius
    var temperature: Int
    /// Turn if currently powered on
    var powered: Bool
    /// Current availability
    var availability: Availability
    /// Listen policy (for Clarius Cast)
    var listenPolicy: ListenPolicy
    /// Charging status
    var chargingStatus: ChargingStatus
    /// ID provided for use in collections
    var id: String { serial }
}



================================================
FILE: examples/cast_swift/Shared/ScannerList.swift
================================================
//
//  ScannerList.swift
//  Solum Example
//
//  List of found scanners
//

import SwiftUI

struct ScannerList: View {

    var scanners: [Scanner]
    var selectedSerial: String
    var body: some View {
        VStack {
            HStack {
                Text("Serial")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("SSID")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("Battery")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("Powered")
                    .bold()
                    .frame(maxWidth: .infinity)
            }
            HStack {
                Text("IP Address")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("Password")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("Temperature")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("Availability")
                    .bold()
                    .frame(maxWidth: .infinity)
            }
            HStack {
                Text("TCP Port")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("-")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("RSSI")
                    .bold()
                    .frame(maxWidth: .infinity)
                Text("Listen")
                    .bold()
                    .frame(maxWidth: .infinity)
            }
            Divider()
            ScrollView {
                VStack {
                    ForEach(scanners) { scanner in
                        let selected = scanner.serial == selectedSerial
                        #if os(iOS)
                        let bgColor = selected ? Color.accentColor : Color(uiColor: .tertiarySystemBackground)
                        #else
                        let bgColor = Color(selected ? NSColor.selectedContentBackgroundColor : NSColor.controlBackgroundColor)
                        #endif
                        VStack {
                            HStack {
                                Text(scanner.serial)
                                    .frame(maxWidth: .infinity)
                                Text(scanner.ssid)
                                    .frame(maxWidth: .infinity)
                                Text("\(scanner.battery)%")
                                    .frame(maxWidth: .infinity)
                                Text(scanner.powered ? "On" : "Off")
                                    .frame(maxWidth: .infinity)
                            }
                            HStack {
                                Text(scanner.ip)
                                    .frame(maxWidth: .infinity)
                                Text(scanner.password)
                                    .frame(maxWidth: .infinity)
                                Text("\(scanner.temperature)°C")
                                    .frame(maxWidth: .infinity)
                                Text(String(describing: scanner.availability))
                                    .frame(maxWidth: .infinity)
                            }
                            HStack {
                                Text(String(scanner.tcpPort))
                                    .frame(maxWidth: .infinity)
                                Text("-")
                                    .frame(maxWidth: .infinity)
                                Text(String(scanner.rssi))
                                    .frame(maxWidth: .infinity)
                                Text(String(describing: scanner.listenPolicy))
                                    .frame(maxWidth: .infinity)
                            }.padding([.bottom], 1)
                        }.background(bgColor).onTapGesture {
                            let userInfo = ["serial": scanner.serial]
                            NotificationCenter.default.post(name: .changeScanner, object: nil, userInfo: userInfo)
                        }
                    }
                }
            }.frame(maxHeight: 200)
        }
    }
}

struct ScannerList_Previews: PreviewProvider {
    static var previews: some View {
        ScannerList(scanners: [
            Scanner(serial: "Test1",
                    ssid: "DIRECT-C3HD3",
                    password: "Secure",
                    ip: "192.168.0.1",
                    tcpPort: 33546,
                    rssi: -59,
                    battery: 75,
                    temperature: 33,
                    powered: false,
                    availability: Availability.available,
                    listenPolicy: ListenPolicy.institution,
                    chargingStatus: ChargingStatus.none
            ),
            Scanner(serial: "Test2",
                    ssid: "DIRECT-L7HD3",
                    password: "Secure",
                    ip: "192.168.0.19",
                  	tcpPort: 37434,
                  	rssi: -30,
                  	battery: 70,
                  	temperature: 29,
                	powered: true,
                    availability: Availability.notAvailable,
                    listenPolicy: ListenPolicy.disabled,
                    chargingStatus: ChargingStatus.done
              )], selectedSerial: "Test2")
    }
}



================================================
FILE: examples/cast_swift/Shared/ScannersModel.swift
================================================
//
//  ScannersModel.swift
//  Solum Example
//
//  Holds a list model for presenting the found scanners
//

import Foundation

/// A list model for presenting the found scanners
class ScannersModel: ObservableObject {
    /// The stored list of scanners with properties collected from elsewhere
    @Published var scanners: [Scanner] = []

    /// Send out the current stored details for the scanner with the given serial
    /// - Parameter serial: Serial of the scanner to send details
    func sendDetails(serial: String) {
        guard let row = self.scanners.firstIndex(where: {$0.serial == serial}) else {
            print("Cannot find details for scanner with serial \(serial)")
            return
        }
        let userInfo = ["scanner": scanners[row]]
        NotificationCenter.default.post(name: .scannerDetails, object: nil, userInfo: userInfo)
    }

    /// Initialization to listen to notifications from other classes
    init() {
        // Listen for notifications from the bluetooth model about found scanners
        NotificationCenter.default.addObserver(forName: .deviceFound, object: nil, queue: nil) { [weak self] notification in
            guard let self = self else {
                return
            }
            guard let userInfo = notification.userInfo else {
                return
            }
            guard let deviceFound = userInfo["device"] as? DeviceFound else {
                return
            }
            if let row = self.scanners.firstIndex(where: {$0.serial == deviceFound.serial}) {
                self.scanners[row].rssi = deviceFound.rssi
                self.scanners[row].battery = deviceFound.battery
                self.scanners[row].temperature = deviceFound.temperature
                self.scanners[row].availability = deviceFound.availability
                self.scanners[row].listenPolicy = deviceFound.listenPolicy
                self.scanners[row].chargingStatus = deviceFound.chargingStatus
            } else {
                self.scanners.append(Scanner(serial: deviceFound.serial, ssid: "-", password: "password", ip: "-", tcpPort: 0, rssi: deviceFound.rssi, battery: deviceFound.battery, temperature: deviceFound.temperature, powered: deviceFound.powered, availability: deviceFound.availability, listenPolicy: deviceFound.listenPolicy, chargingStatus: deviceFound.chargingStatus))
            }
        }
        // Listen for notifications from the bluetooth model about Wi-Fi info from scanners
        NotificationCenter.default.addObserver(forName: .wifiInfoReceived, object: nil, queue: nil) { [weak self] notification in
            guard let self = self else {
                return
            }
            guard let userInfo = notification.userInfo else {
                return
            }
            guard let serial = userInfo["serial"] as? String else {
                return
            }
            guard let wifiInfo = userInfo["wifiInfo"] as? WifiInfo else {
                return
            }
            guard let row = self.scanners.firstIndex(where: {$0.serial == serial}) else {
                return
            }
            self.scanners[row].ssid = wifiInfo.ssid
            self.scanners[row].password = wifiInfo.password
            self.scanners[row].ip = wifiInfo.ip
            self.scanners[row].tcpPort = wifiInfo.port
        }
        // Listen for notifications from the bluetooth model about powered status
        NotificationCenter.default.addObserver(forName: .poweredChanged, object: nil, queue: nil) { [weak self] notification in
            guard let self = self else {
                return
            }
            guard let userInfo = notification.userInfo else {
                return
            }
            guard let serial = userInfo["serial"] as? String else {
                return
            }
            guard let powered = userInfo["powered"] as? Bool else {
                return
            }
            guard let row = self.scanners.firstIndex(where: {$0.serial == serial}) else {
                return
            }
            self.scanners[row].powered = powered
        }
    }
}



================================================
FILE: examples/cast_swift/Shared/Assets.xcassets/Contents.json
================================================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/cast_swift/Shared/Assets.xcassets/AccentColor.colorset/Contents.json
================================================
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/cast_swift/Shared/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "20x20"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "29x29"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "40x40"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "76x76"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "16x16"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "32x32"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "128x128"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "256x256"
    },
    {
      "idiom" : "mac",
      "scale" : "1x",
      "size" : "512x512"
    },
    {
      "idiom" : "mac",
      "scale" : "2x",
      "size" : "512x512"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/cast_swift/Shared/Assets.xcassets/BlankImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "filename" : "black.jpeg",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}



================================================
FILE: examples/caster/caster.pro
================================================
TARGET = caster
TEMPLATE = app
CONFIG += c++17 console

LIBPATH = $$PWD/../../lib
INCLUDEPATH += $$PWD/../../include
LIBS += -L$$LIBPATH/ -lcast

SOURCES += main.cpp



================================================
FILE: examples/caster/main.cpp
================================================
#include <stdio.h>
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
#include <atomic>
#include <thread>

#ifdef _MSC_VER
#include <boost/program_options.hpp>
#else
#include <unistd.h>
#endif

#include <cast/cast.h>

#define PRINT           std::cout << std::endl
#define PRINTSL         std::cout << "\r"
#define ERROR           std::cerr << std::endl

static char* buffer_ = nullptr;
static int szRawData_ = 0;
static int counter_ = 0;
static bool streamOutput_ = true;
static long long int lasttime_ = 0;
static int captureID_ = -1;

/// callback for error messages
/// @param[in] err the error message sent from the casting module
void errorFn(const char* err)
{
    ERROR << "error: " << err;
}

/// callback for freeze state change
/// @param[in] val the freeze state value, 1 = frozen, 0 = imaging
void freezeFn(int val)
{
    PRINT << (val ? "frozen" : "imaging");
    counter_ = 0;
}

/// callback for button press
/// @param[in] btn the button that was pressed, 0 = up, 1 = down
/// @param[in] clicks # of clicks used
void buttonFn(CusButton btn, int clicks)
{
    PRINT << ((btn == ButtonDown) ? "down" : "up") << " button pressed, clicks: " << clicks;
}

/// callback for readback progress
/// @param[in] progress the readback progress
void progressFn(int progress)
{
    PRINTSL << "downloading: " << progress << "%" << std::flush;
}

/// prints imu data
/// @param[in] npos the # of positional data points embedded with the frame
/// @param[in] pos the buffer of positional data
void printImuData(int npos, const CusPosInfo* pos)
{
    for (auto i = 0; i < npos; i++)
    {
        PRINT << "imu: " << i << ", time: " << pos[i].tm;
        PRINT << "accel: " << pos[i].ax << "," << pos[i].ay << "," << pos[i].az;
        PRINT << "gyro: " << pos[i].gx << "," << pos[i].gy << "," << pos[i].gz;
        PRINT << "magnet: " << pos[i].mx << "," << pos[i].my << "," << pos[i].mz;
    }
}

/// @brief Receives the new imu data streamed from the scanner
/// @param pos the positional information data streamed
void newImuData(const CusPosInfo* pos)
{
    PRINT << "imu data streamed:";
    printImuData(1, pos);
}

/// callback for a new pre-scan converted data sent from the scanner
/// @param[in] newImage a pointer to the raw image bits
/// @param[in] nfo the image properties
/// @param[in] npos the # of positional data points embedded with the frame
/// @param[in] pos the buffer of positional data
void newRawImageFn(const void* newImage, const CusRawImageInfo* nfo, int npos, const CusPosInfo* pos)
{
    lasttime_ = nfo->tm;
#ifdef PRINTRAW
    if (nfo->rf)
        PRINT << "new rf data (" << newImage << "): " << nfo->lines << " x " << nfo->samples << " @ " << nfo->bitsPerSample
          << "bits. @ " << nfo->axialSize << " microns per sample. imu points: " << npos;
    else
        PRINT << "new pre-scan data (" << newImage << "): " << nfo->lines << " x " << nfo->samples << " @ " << nfo->bitsPerSample
          << "bits. @ " << nfo->axialSize << " microns per sample. imu points: " << npos << " jpeg size: " << static_cast<int>(nfo->jpeg);

    if (npos)
        printImuData(npos, pos);
#else
    (void)newImage;
    (void)npos;
    (void)pos;
#endif
}

/// callback for a new image sent from the scanner
/// @param[in] newImage a pointer to the raw image bits
/// @param[in] nfo the image properties
/// @param[in] npos the # of positional data points embedded with the frame
/// @param[in] pos the buffer of positional data
void newProcessedImageFn(const void* newImage, const CusProcessedImageInfo* nfo, int npos, const CusPosInfo* pos)
{
    (void)newImage;
    (void)pos;
    if (streamOutput_)
        PRINTSL << "new image (" << counter_++ << "): " << nfo->width << " x " << nfo->height << " @ " << nfo->bitsPerPixel << " bpp. @ "
                << nfo->imageSize << "bytes. @ " << nfo->micronsPerPixel << " microns per pixel. imu points: " << npos << std::flush;
}

/// callback for a new spectral image sent from the scanner
/// @param[in] newImage a pointer to the raw image bits
/// @param[in] nfo the image properties
void newSpectralImageFn(const void* newImage, const CusSpectralImageInfo* nfo)
{
    (void)newImage;
    if (streamOutput_)
        PRINTSL << "new spectrum: " << nfo->lines << " x " << nfo->samples << " @ " << nfo->bitsPerSample
              << "bits. @ " << nfo->period << " sec/line." << std::flush;
}

/// saves raw data from the current download buffer
/// @return success of the call
bool saveRawData()
{
    if (!szRawData_ || !buffer_)
        return false;

    auto cleanup = []()
    {
        free(buffer_);
        buffer_ = nullptr;
        szRawData_ = 0;
    };

    FILE* fp = nullptr;
    // save raw data to disk as a compressed file
    #ifdef _MSC_VER
        fopen_s(&fp, "raw_data.tar", "wb+");
    #else
        fp = fopen("raw_data.tar", "wb+");
    #endif
    if (!fp)
    {
        cleanup();
        return false;
    }

    fwrite(buffer_, szRawData_, 1, fp);
    fclose(fp);
    cleanup();
    return true;
}

void doneCapture(int result)
{
    if (result < 0)
        ERROR << "failed to submit capture";
    else
        PRINT << "successfully submitted capture";
}

char getCommand(const std::string& line)
{
    if (line.empty() || (line.size() > 1 && line[1] != ' '))
        return '\0';
    return line[0];
}

std::vector<std::string> getParameters(const std::string& line, std::size_t max)
{
    std::vector<std::string> result;
    if (line.size() < 2 || line[1] != ' ')
        return result;
    std::size_t lastIndex = 2;
    std::size_t nextIndex = line.find(' ', lastIndex);
    while (lastIndex < line.size())
    {
        const bool addAll = (nextIndex == std::string::npos || result.size() + 1 == max);
        std::size_t count = (addAll ? line.length() : nextIndex + 1) - lastIndex;
        result.push_back(line.substr(lastIndex, addAll ? count : count - 1));
        lastIndex += count;
        nextIndex = line.find(' ', lastIndex);
    }
    return result;
}

bool parseDouble(double& val, const std::string& param)
{
    try
    {
        val = std::stod(param);
        return true;
    }
    catch (std::exception& e)
    {
        ERROR << e.what() << std::endl;
        return false;
    }
}

/// processes the user input
/// @param[out] quit the exit flag
void processEventLoop(std::atomic_bool& quit)
{
    std::string line;

    while (std::getline(std::cin, line))
    {
        const char cmd = getCommand(line);
        if (cmd == 'Q' || cmd == 'q')
        {
            quit = true;
            break;
        }
        else if (cmd == 'F' || cmd == 'f')
        {
            if (castUserFunction(Freeze, 0, nullptr) < 0)
                ERROR << "error toggling freeze" << std::endl;
        }
        else if (cmd == 'D')
        {
            if (castUserFunction(DepthInc, 0, nullptr) < 0)
                ERROR << "error incrementing depth" << std::endl;
        }
        else if (cmd == 'd')
        {
            if (castUserFunction(DepthDec, 0, nullptr) < 0)
                ERROR << "error decrementing depth" << std::endl;
        }
        else if (cmd == 'G')
        {
            if (castUserFunction(GainInc, 0, nullptr) < 0)
                ERROR << "error incrementing gain" << std::endl;
        }
        else if (cmd == 'g')
        {
            if (castUserFunction(GainDec, 0, nullptr) < 0)
                ERROR << "error decrementing gain" << std::endl;
        }
        else if (cmd == 'S' || cmd == 's')
        {
            streamOutput_ = !streamOutput_;
        }
        else if (cmd == 'R' || cmd == 'r')
        {
            if (castRequestRawData(0, 0, 1, [](int sz, const char*)
            {
                if (sz < 0)
                    ERROR << "error requesting raw data" << std::endl;
                else if (sz == 0)
                {
                    szRawData_ = 0;
                    ERROR << "no raw data buffered" << std::endl;
                }
                else
                {
                    szRawData_ = sz;
                    PRINT << "raw data file of size " << sz << "B ready to download";
                }

            }) < 0)
                ERROR << "error requesting raw data" << std::endl;
        }
        else if (cmd == 'Y' || cmd == 'y')
        {
            if (szRawData_ <= 0)
                ERROR << "no raw data to download" << std::endl;
            else
            {
                buffer_ = reinterpret_cast<char*>(malloc(szRawData_));

                if (castReadRawData((void**)(&buffer_), [](int ret)
                {
                    if (ret == CUS_SUCCESS)
                    {
                        PRINT << "successfully downloaded raw data" << std::endl;
                        saveRawData();
                    }
                }) < 0)
                    ERROR << "error downloading raw data" << std::endl;
            }
        }
        else if (cmd == 'C' || cmd == 'c')
        {
            if (lasttime_ == 0)
            {
                ERROR << "no images received yet" << std::endl;
                continue;
            }
            if (captureID_ < 0)
            {
                captureID_ = castStartCapture(lasttime_);
                if (captureID_ < 0)
                    ERROR << "failed to start capture" << std::endl;
                else
                    PRINT << "started capture " << captureID_ << std::endl;
            }
            else
            {
                if (castFinishCapture(captureID_, &doneCapture) < 0)
                    ERROR << "failed to finish capture" << std::endl;
                else
                    PRINT << "finished capture " << captureID_ << std::endl;
                captureID_ = -1;
            }
        }
        else if (cmd == 'l' || cmd == 'L')
        {
            if (captureID_ < 0)
            {
                ERROR << "no capture in progress" << std::endl;
                continue;
            }
            const std::vector<std::string> prms = getParameters(line, 3);
            double x = 0;
            double y = 0;
            if (prms.size() < 3 || !parseDouble(x, prms[0]) || !parseDouble(y, prms[1]))
            {
                ERROR << "wrong label parameters provided";
                ERROR << "please give parameters as -> x y text";
                ERROR << "where x and y are the coordinates of the center of the label" << std::endl;
                continue;
            }
            if (castAddLabelOverlay(captureID_, prms.back().c_str(), x, y, 100.0, 100.0) < 0)
                ERROR << "failed to add label to capture" << std::endl;
            else
                PRINT << "added label '" << prms.back() << "' at (" << x << ", " << y << ") to capture" << std::endl;
        }
        else if (cmd == 'm' || cmd == 'M')
        {
            if (captureID_ < 0)
            {
                ERROR << "no capture in progress" << std::endl;
                continue;
            }
            const std::vector<std::string> prms = getParameters(line, 5);
            double x1 = 0;
            double y1 = 0;
            double x2 = 0;
            double y2 = 0;
            if (prms.size() < 5
                || !parseDouble(x1, prms[0]) || !parseDouble(y1, prms[1])
                || !parseDouble(x2, prms[2]) || !parseDouble(y2, prms[3]))
            {
                ERROR << "wrong measurement parameters provided";
                ERROR << "please give parameters as -> x1 y1 x2 y2 text";
                ERROR << "for a measurement from (x1,y1) to (x2,y2) with label 'text'" << std::endl;
                continue;
            }
            const double points[] = { x1, y1, x2, y2 };
            const int nDoubles = static_cast<int>(sizeof(points) / sizeof(points[0]));
            if (castAddMeasurement(captureID_, CusMeasurementTypeDistance, prms.back().c_str(), points, nDoubles) < 0)
                ERROR << "failed to add label to capture" << std::endl;
            else
                PRINT << "added measurement '" << prms.back() << "' from (" << x1 << ", " << y1 << ") "
                    << "to (" << x2 << ", " << y2 << ") to capture" << std::endl;
        }
        else if (cmd == 'p' || cmd == 'P')
        {
            const std::vector<std::string> prms = getParameters(line, 2);
            if (prms.size() != 2)
            {
                ERROR << "usage: p {param_name} {param_value}" << std::endl;
                continue;
            }
            std::string prm = prms[0];
            std::transform(prm.begin(), prm.end(), prm.begin(), ::tolower);
            if (prms[1] == "true" || prms[1] == "false")
            {
                if (castEnableParameter(prms[0].c_str(), (prms[1] == "true"), [](int ret)
                {
                    if (ret == CUS_FAILURE)
                        ERROR << "parameter enable/disable failed";
                }) < 0)
                {
                    ERROR << "parameter enable/disable failed";
                }
            }
            else if (prm.find("pulse") != std::string::npos)
            {
                if (castSetPulse(prms[0].c_str(), prms[1].c_str(), [](int ret)
                {
                    if (ret == CUS_FAILURE)
                        ERROR << "parameter pulse shape set failed";
                }) < 0)
                {
                    ERROR << "parameter pulse shape set failed";
                }
            }
            else
            {
                double val = 0;
                if (!parseDouble(val, prms[1]))
                {
                    ERROR << "could not convert parameter value to numeric value";
                    continue;
                }
                if (castSetParameter(prms[0].c_str(), val, [](int ret)
                {
                    if (ret == CUS_FAILURE)
                        ERROR << "parameter setting parameter";
                }) < 0)
                {
                    ERROR << "parameter setting parameter";
                }
            }
        }
        else
        {
            PRINT << "valid commands: [q: quit]";
            PRINT << "       display: [s: toggle stream outptu]";
            PRINT << "       imaging: [f: freeze, d/D: depth, g/G: gain]";
            PRINT << "        params: [p: change parameter]";
            PRINT << "      raw data: [r: request, y: download]";
            PRINT << "       capture: [c: start/end capture, l: add label, m: add measurement]" << std::endl;
        }
    }
}

int init(int& argc, char** argv)
{
    const int width  = 640;
    const int height = 480;
    std::string keydir, ipAddr;
    unsigned int port = 0;

    // ensure console buffers are flushed automatically
    setvbuf(stdout, nullptr, _IONBF, 0) != 0 || setvbuf(stderr, nullptr, _IONBF, 0);

    // Windows: Visual C++ doesn't have 'getopt' so use Boost's program_options instead
#ifdef _MSC_VER
    namespace po = boost::program_options;
    keydir = "c:/";

    try
    {
        po::options_description desc("Usage: 192.168.1.21", 12345);
        desc.add_options()
            ("help", "produce help message")
            ("address", po::value<std::string>(&ipAddr)->required(), "set the IP address of the host scanner")
            ("port", po::value<unsigned int>(&port)->required(), "set the port of the host scanner")
            ("keydir", po::value<std::string>(&keydir)->default_value("/tmp/"), "set the path containing the security keys")
        ;

        po::variables_map vm;
        po::store(po::command_line_parser(argc, argv).options(desc).allow_unregistered().run(), vm);

        if (vm.count("help"))
        {
            PRINT << desc << std::endl;
            return CUS_FAILURE;
        }

        po::notify(vm);
    }
    catch (std::exception& e)
    {
        ERROR << "Error: " << e.what() << std::endl;
        return CUS_FAILURE;
    }
    catch (...)
    {
        ERROR << "Unknown error!" << std::endl;
        return CUS_FAILURE;
    }
#else // every other platform has 'getopt' which we're using so as to not pull in the Boost dependency
    int o;
    keydir = "/tmp/";

    // check command line options
    while ((o = getopt(argc, argv, "k:a:p:")) != -1)
    {
        switch (o)
        {
        // security key directory
        case 'k': keydir = optarg; break;
        // ip address
        case 'a': ipAddr = optarg; break;
        // port
        case 'p':
            try { port = std::stoi(optarg); }
            catch (std::exception&) { PRINT << port; }
            break;
        // invalid argument
        case '?': PRINT << "invalid argument, valid options: -a [addr], -p [port], -k [keydir]"; break;
        default: break;
        }
    }

    if (!ipAddr.size())
    {
        ERROR << "no ip address provided. run with '-a [addr]" << std::endl;
        return CUS_FAILURE;
    }

    if (!port)
    {
        ERROR << "no casting port provided. run with '-p [port]" << std::endl;
        return CUS_FAILURE;
    }
#endif

    PRINT << "starting caster...";

    auto initParams = castDefaultInitParams();
    initParams.args.argc = argc;
    initParams.args.argv = argv;
    initParams.storeDir = keydir.c_str();
    initParams.newProcessedImageFn = newProcessedImageFn;
    initParams.newRawImageFn = newRawImageFn;
    initParams.newSpectralImageFn = newSpectralImageFn;
    initParams.newImuDataFn = newImuData;
    initParams.freezeFn = freezeFn;
    initParams.buttonFn = buttonFn;
    initParams.progressFn = progressFn;
    initParams.errorFn = errorFn;
    initParams.width = width;
    initParams.height = height;
    // initialize with callbacks
    if (castInit(&initParams) < 0)
    {
        ERROR << "could not initialize caster" << std::endl;
        return CUS_FAILURE;
    }
    if (castConnect(ipAddr.c_str(), port, "research", [](int imagePort, int imuPort, int swRevMatch)
    {
        if (imagePort == CUS_FAILURE)
            ERROR << "could not connect to scanner" << std::endl;
        else
        {
            PRINT << "...connected, streaming port: " << imagePort << " -- check firewall settings if no image callback received";
            if (imuPort > 0)
            {
                PRINT << "imu now streaming at port: " << imuPort;
            }
            else
            {
                PRINT << "imu streaming off";
            }
            if (swRevMatch == CUS_FAILURE)
                ERROR << "software revisions do not match, that is not necessarily a problem" << std::endl;
        }

    }) < 0)
    {
        ERROR << "connection attempt failed" << std::endl;
        return CUS_FAILURE;
    }

    return 0;
}

/// main entry point
/// @param[in] argc # of program arguments
/// @param[in] argv list of arguments
int main(int argc, char* argv[])
{
    int rcode = init(argc, argv);

    if (rcode == CUS_SUCCESS)
    {
        std::atomic_bool quitFlag(false);
        std::thread eventLoop(processEventLoop, std::ref(quitFlag));
        eventLoop.join();
    }

    castDestroy();
    return rcode;
}



================================================
FILE: examples/caster/Makefile
================================================
TARGET_EXEC ?= $(notdir $(CURDIR))

BUILD_DIR ?= ./build
SRC_DIRS ?= ./
CAST_SDK ?= ../..

SRCS := $(shell find $(SRC_DIRS) -name *.cpp -or -name *.c -or -name *.s)
OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)
DEPS := $(OBJS:.o=.d)

INC_DIRS := $(shell find $(SRC_DIRS) -type d)
INC_DIRS += $(CAST_SDK)/include
INC_FLAGS := $(addprefix -I,$(INC_DIRS))

CPPFLAGS += $(INC_FLAGS)
CXXFLAGS += -std=gnu++14
LDFLAGS += -L$(CAST_SDK)/lib -lcast -lpthread

ifeq ($(shell uname -s),Darwin)
	LDFLAGS += -rpath ${CAST_SDK}/lib
endif

$(BUILD_DIR)/$(TARGET_EXEC): $(OBJS)
	$(CXX) $(OBJS) -o $@ $(LDFLAGS)

# assembly
$(BUILD_DIR)/%.s.o: %.s
	$(MKDIR_P) $(dir $@)
	$(AS) $(ASFLAGS) -c $< -o $@

# c source
$(BUILD_DIR)/%.c.o: %.c
	$(MKDIR_P) $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

# c++ source
$(BUILD_DIR)/%.cpp.o: %.cpp
	$(MKDIR_P) $(dir $@)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@


.PHONY: clean

clean:
	$(RM) -r $(BUILD_DIR)

-include $(DEPS)

MKDIR_P ?= mkdir -p



================================================
FILE: examples/caster_qt/3d.cpp
================================================
#include "3d.h"

using namespace Qt3DCore;
using namespace Qt3DRender;
using namespace Qt3DExtras;

#define DEFAULT_VIEW    0.5, 0.5, -0.5, 0.5

/// default constructor
ProbeRender::ProbeRender(QScreen* sc) : Qt3DWindow(sc), orientation_(QQuaternion(DEFAULT_VIEW))
{
}

/// initializes the renderer
/// @param[in] model path to the model to load
/// @return success of the call
bool ProbeRender::init(const QString& model)
{
    auto sc = createScene(model);
    auto cam = camera();
    cam->lens()->setPerspectiveProjection(50, 16.0f / 9.0f, 0.1f, 1000);
    cam->setPosition(QVector3D(0, 0, 30));
    cam->setViewCenter(QVector3D(0, 0, 0));
    setRootEntity(sc);
    return true;
}

/// creates the scene to render to
/// @param[in] model path to the model to load
/// @return the root entity
QEntity* ProbeRender::createScene(const QString& model)
{
    QEntity* root = new QEntity;
    probeEntity_ = new QEntity(root);
    probe_ = new QSceneLoader(probeEntity_);
    probe_->setSource(QUrl::fromLocalFile(model));
    probeEntity_->addComponent(probe_);
    addTransform();
    return root;
}

/// adds a new transform based on the latest orientation
void ProbeRender::addTransform()
{
    transform_.setScale3D(QVector3D(100, 100, 100));
    QQuaternion axisCorrection(QQuaternion::fromEulerAngles(0, 180, 90));
    QQuaternion modelCorrection(QQuaternion::fromEulerAngles(-90, 0, 90));
    auto modelRotation = orientation_ * axisCorrection;
    auto correctedOrientation = modelCorrection * modelRotation;
    transform_.setRotation(correctedOrientation);
    probeEntity_->addComponent(&transform_);
}

/// updates the latest orientation
/// @param[in] imu the latest imu data
void ProbeRender::update(const QQuaternion& imu)
{
    orientation_ = imu;
    addTransform();
}

/// resets the view
void ProbeRender::reset()
{
    update(QQuaternion(DEFAULT_VIEW));
}



================================================
FILE: examples/caster_qt/3d.h
================================================
#pragma once

/// probe rendering output
class ProbeRender : public Qt3DExtras::Qt3DWindow
{
    Q_OBJECT
public:
    explicit ProbeRender(QScreen* sc);
    bool init(const QString& model);
    void reset();
    void update(const QQuaternion& imu);

private:
    Qt3DCore::QEntity* createScene(const QString& model);
    void addTransform();

private:
    QQuaternion orientation_;           ///< current orientation
    Qt3DCore::QTransform transform_;    ///< transform matrix
    Qt3DCore::QEntity* probeEntity_;    ///< probe model node
    Qt3DRender::QSceneLoader* probe_;   ///< probe model scene
};



================================================
FILE: examples/caster_qt/caster.cpp
================================================
#include "caster.h"
#include "display.h"
#include "3d.h"
#include "ui_caster.h"
#include <cast/cast.h>

static Caster* _me;

/// default constructor
/// @param[in] parent the parent object
Caster::Caster(QWidget *parent) : QMainWindow(parent), connected_(false), frozen_(false), lasttime_(0), imuSamples_(0), ui_(new Ui::Caster)
{
    _me = this;
    ui_->setupUi(this);
    setWindowIcon(QIcon(":/res/cast.png"));
    image_ = new UltrasoundImage(this);
    signal_ = new RfSignal(this);
    ui_->image->addWidget(image_);
    ui_->image->addWidget(signal_);
    imageTimer_.setSingleShot(true);

    render_ = new ProbeRender(QGuiApplication::primaryScreen());
    ui_->render->addWidget(QWidget::createWindowContainer(render_));
    auto reset = new QPushButton(QStringLiteral("Reset"), this);
    ui_->render->addWidget(reset);
    render_->init(QStringLiteral(":/res/l15.obj"));
    render_->show();

    settings_ = std::make_unique<QSettings>(QStringLiteral("settings.ini"), QSettings::IniFormat);
    auto ip = settings_->value("ip").toString();
    if (!ip.isEmpty())
        ui_->ip->setText(ip);
    auto port = settings_->value("port").toString();
    if (!port.isEmpty())
        ui_->port->setText(port);

    connect(&imageTimer_, &QTimer::timeout, [this]()
    {
        image_->setNoImage(true);
        lasttime_ = 0;
        updateCaptureButtons();
        ui_->status->showMessage(NO_IMAGE_STATEMENT);
    });

    QObject::connect(reset, &QPushButton::clicked, [this]()
    {
        render_->reset();
        imuSamples_ = 0;
    });
}

/// destructor
Caster::~Caster()
{
    delete ui_;
}

/// called when the window is closing to clean up the clarius library
void Caster::closeEvent(QCloseEvent*)
{
    if (connected_)
        castDisconnect(nullptr);

    castDestroy();
}

/// handles custom events posted by caster api callbacks
/// @param[in] event the event to parse
/// @return handling status
bool Caster::event(QEvent *event)
{
    if (event->type() == IMAGE_EVENT)
    {
        auto evt = static_cast<event::Image*>(event);
        newProcessedImage(evt->data_, evt->width_, evt->height_, evt->bpp_, evt->size_, evt->imu_);
        image_->setNoImage(false);
        lasttime_ = evt->tm_;
        updateCaptureButtons();
        if (imageTimer_.isActive())
            imageTimer_.stop();

        return true;
    }
    else if (event->type() == PRESCAN_EVENT)
    {
        auto evt = static_cast<event::Image*>(event);
        newPrescanImage(evt->data_, evt->width_, evt->height_, evt->bpp_, evt->size_);
        return true;
    }
    else if (event->type() == RF_EVENT)
    {
        auto evt = static_cast<event::RfImage*>(event);
        newRfData(evt->data_, evt->width_, evt->height_, evt->bpp_, evt->lateral_, evt->axial_);
        return true;
    }
    else if (event->type() == SPECTRUM_EVENT)
    {
        auto evt = static_cast<event::Spectrum*>(event);
        if (evt->pw_)
            newPwSpectrum(evt->data_, evt->width_, evt->height_, evt->bpp_, evt->period_, evt->velocityPerSample_);
        else
            newMSpectrum(evt->data_, evt->width_, evt->height_, evt->bpp_, evt->period_, evt->micronsPerSample_);
        return true;
    }
    else if (event->type() == FREEZE_EVENT)
    {
        setFreeze((static_cast<event::Freeze*>(event))->frozen_);
        return true;
    }
    else if (event->type() == BUTTON_EVENT)
    {
        auto evt = static_cast<event::Button*>(event);
        onButton(evt->button_, evt->clicks_);
        return true;
    }
    else if (event->type() == PROGRESS_EVENT)
    {
        setProgress((static_cast<event::Progress*>(event))->progress_);
        return true;
    }
    else if (event->type() == RAWDATA_EVENT)
    {
        rawDataReady((static_cast<event::RawData*>(event))->success_);
        return true;
    }
    else if (event->type() == ERROR_EVENT)
    {
        setError((static_cast<event::Error*>(event))->error_);
        return true;
    }
    else if (event->type() == IMU_EVENT)
    {
        auto evt = static_cast<event::Imu*>(event);
        newImuData(evt->imu_);
        return true;
    }

    return QMainWindow::event(event);
}

/// called when the api returns an error
/// @param[in] err the error message
void Caster::setError(const QString& err)
{
    ui_->status->showMessage(QStringLiteral("Error: %1").arg(err));
}

/// called when the freeze status changes
/// @param[in] en the freeze state
void Caster::setFreeze(bool en)
{
    frozen_ = en;
    if (!frozen_)
        lasttime_ = 0;
    ui_->status->showMessage(QStringLiteral("Image: %1").arg(en ? QStringLiteral("Frozen") : QStringLiteral("Running")));
    ui_->freeze->setText(en ? QStringLiteral("Run") : QStringLiteral("Stop"));
    ui_->request->setEnabled(en);
    ui_->download->setEnabled(false);
    ui_->shallower->setEnabled(!en);
    ui_->deeper->setEnabled(!en);
    updateCaptureButtons();
    rawData_ = RawDataInfo();

    if (!en)
        imageTimer_.start(3000);
    else
        imageTimer_.stop();
}

void Caster::updateCaptureButtons()
{
    ui_->addLabel->setEnabled(lasttime_ != 0);
    ui_->captureImage->setEnabled(lasttime_ != 0);
}

/// called when there is a button press on the ultrasound
/// @param[in] btn the button pressed
/// @param[in] clicks # of clicks used
void Caster::onButton(int btn, int clicks)
{
    ui_->status->showMessage(QStringLiteral("Button %1 Pressed, %2 Clicks").arg(btn ? QStringLiteral("Down") : QStringLiteral("Up")).arg(clicks));
}

/// called when the download progress changes
/// @param[in] progress the current progress
void Caster::setProgress(int progress)
{
    ui_->progress->setValue(progress);
}

/// called when a new image has been sent
/// @param[in] img the image data
/// @param[in] w width of the image
/// @param[in] h height of the image
/// @param[in] bpp the bits per pixel
/// @param[in] sz size of the image in bytes
void Caster::newProcessedImage(const void* img, int w, int h, int bpp, int sz, const QQuaternion& imu)
{
    image_->loadImage(img, w, h, bpp, sz);
    if (!imu.isNull())
        render_->update(imu);
}

/// called when a new pre-scan image has been sent
/// @param[in] img the image data
/// @param[in] w width of the image
/// @param[in] h height of the image
/// @param[in] bpp the bits per pixel
/// @param[in] sz size of the image in bytes
void Caster::newPrescanImage(const void* img, int w, int h, int bpp, int sz)
{
    if (sz == (w * h * (bpp / 8)))
        prescan_ = QImage(reinterpret_cast<const uchar*>(img), w, h, QImage::Format_ARGB32);
    else
        prescan_.loadFromData(static_cast<const uchar*>(img), sz, "JPG");
}

/// called when new rf data has been sent
/// @param[in] rfdata the rf data
/// @param[in] l # of lines
/// @param[in] s # of samples
/// @param[in] bps the bits per sample (should always be 16)
/// @param[in] lateral spacing between lines
/// @param[in] axial sample size
void Caster::newRfData(const void* rfdata, int l, int s, int bps, double lateral, double axial)
{
    signal_->loadSignal(rfdata, l, s, bps / 8);
    Q_UNUSED(lateral)
    Q_UNUSED(axial)
}

/// called when new m spectral data has been sent
/// @param[in] rfdata the rf data
/// @param[in] l # of lines
/// @param[in] s # of samples
/// @param[in] bps the bits per sample
/// @param[in] period seconds per line
/// @param[in] micronsPerSample # of microns per sample
void Caster::newMSpectrum(const void* rfdata, int l, int s, int bps, double period, double micronsPerSample)
{
    Q_UNUSED(rfdata)
    Q_UNUSED(l)
    Q_UNUSED(s)
    Q_UNUSED(bps)
    Q_UNUSED(period)
    Q_UNUSED(micronsPerSample)
}

/// called when new pw spectral data has been sent
/// @param[in] rfdata the rf data
/// @param[in] l # of lines
/// @param[in] s # of samples
/// @param[in] bps the bits per sample
/// @param[in] period seconds per line
/// @param[in] velocityPerSample speed per sample in m/s
void Caster::newPwSpectrum(const void* rfdata, int l, int s, int bps, double period, double velocityPerSample)
{
    Q_UNUSED(rfdata)
    Q_UNUSED(l)
    Q_UNUSED(s)
    Q_UNUSED(bps)
    Q_UNUSED(period)
    Q_UNUSED(velocityPerSample)
}

/// handles the connection result
/// @param[in] imagePort the image udp streaming port, 0 if failure
/// @param[in] imuPort the imu udp streaming port, 0 if failure
void Caster::connected(int imagePort, int imuPort)
{
    if (imagePort > 0)
    {
        ui_->status->showMessage(QString("Connection successful, streaming port: %1, imu port: %2").arg(imagePort).arg(imuPort));
        connected_ = true;
        ui_->connect->setText("Disconnect");
        ui_->freeze->setEnabled(true);
        ui_->shallower->setEnabled(true);
        ui_->deeper->setEnabled(true);
    }
    else
        ui_->status->showMessage("Could not connect to the specified device");
}

/// handles the disconnection result
/// @param[in] res the disconnection result
void Caster::disconnected(bool res)
{
    if (res)
    {
        ui_->status->showMessage("Disconnect successful");
        connected_ = false;
        ui_->connect->setText("Connect");
        ui_->freeze->setEnabled(false);
        ui_->shallower->setEnabled(false);
        ui_->deeper->setEnabled(false);
    }
    else
        ui_->status->showMessage("Could not disconnect");
}

/// called when the connect/disconnect button is clicked
void Caster::onConnect()
{
    if (!connected_)
    {
        if (castConnect(ui_->ip->text().toStdString().c_str(), ui_->port->text().toInt(), "research",
            [](int imagePort, int imuPort, int swRevMatch)
        {
            _me->ui_->swRevMatch->setText((swRevMatch == CUS_SUCCESS) ? "Matches" : "Mismatch");
            _me->connected(imagePort, imuPort);
        }) < 0)
        {
            ui_->status->showMessage("Connection attempt failed");
        }

        settings_->setValue("ip", ui_->ip->text());
        settings_->setValue("port", ui_->port->text());
    }
    else
    {
        if (castDisconnect([](int ret)
        {
            _me->disconnected(ret == CUS_SUCCESS);
        }) < 0)
            ui_->status->showMessage("Disconnect attempt failed");
    }
}

/// called when the freeze button is clicked
void Caster::onFreeze()
{
    if (!connected_)
        return;

    if (castUserFunction(Freeze, 0, nullptr) < 0)
        ui_->status->showMessage("Toggle freeze failed");
}

/// called when the shallower button is clicked
void Caster::onShallower()
{
    if (!connected_)
        return;

    if (castUserFunction(DepthDec, 0, nullptr) < 0)
        ui_->status->showMessage("Could not image shallower");
}

/// called when the deeper button is clicked
void Caster::onDeeper()
{
    if (!connected_)
        return;

    if (castUserFunction(DepthInc, 0, nullptr) < 0)
        ui_->status->showMessage("Could not image deeper");
}

/// called when the addLabel button is clicked
void Caster::onAddLabel()
{
    QString label = ui_->labelText->text();
    if (label.isEmpty())
    {
        ui_->status->showMessage("No label text provided");
        return;
    }
    image_->addLabel(label);
}

/// called when the addTrace button is clicked
void Caster::onAddTrace()
{
    QString label = ui_->labelText->text();
    if (label.isEmpty())
    {
        ui_->status->showMessage("No label text provided");
        return;
    }
    image_->addTrace(label);
}

/// called when the captureImage button is clicked
void Caster::onCaptureImage()
{
    if (lasttime_ == 0)
    {
        ui_->status->showMessage("No image to capture");
        return;
    }
    const int captureID = castStartCapture(lasttime_);
    if (captureID < 0)
    {
        ui_->status->showMessage("Failed to initialize capture");
        return;
    }
    const std::vector<LabelInfo> labels = image_->getLabels();
    for (const LabelInfo& label : labels)
    {
        const std::string text = label.text_.toStdString();
        const QPointF center = label.rect_.center();
        if (castAddLabelOverlay(captureID, text.c_str(), center.x(), center.y(), label.rect_.width(), label.rect_.height()) < 0)
            ui_->status->showMessage("Failed to add label " + label.text_ + " to capture");
    }
    const std::vector<TraceInfo> traces = image_->getTraces();
    for (const TraceInfo& trace : traces)
    {
        const std::string text = trace.text_.toStdString();
        std::vector<double> points;
        for (const QPointF& pt : trace.points_)
        {
            points.push_back(pt.x());
            points.push_back(pt.y());
        }
        if (castAddMeasurement(captureID, CusMeasurementTypeTraceDistance, text.c_str(), points.data(), static_cast<int>(points.size())) < 0)
            ui_->status->showMessage("Failed to add trace measurement " + trace.text_ + " to capture");
    }
    const QImage overlayImage = image_->overlayImage();
    if (!overlayImage.isNull())
    {
        const QColor overlayColor = image_->overlayColor();
        const int height = overlayImage.height();
        const int width = overlayImage.width();
        std::vector<unsigned char> bytes(width * height);
        for (int i = 0; i < height; ++i)
        {
            std::memcpy(bytes.data() + i * width, overlayImage.scanLine(i), width);
        }
        castAddImageOverlay(
            captureID,
            bytes.data(),
            width,
            height,
            static_cast<float>(overlayColor.redF()),
            static_cast<float>(overlayColor.greenF()),
            static_cast<float>(overlayColor.blueF()),
            static_cast<float>(overlayColor.alphaF())
        );
    }
    if (castFinishCapture(captureID, [](int ret)
    {
        if (ret < 0)
            _me->ui_->status->showMessage("Failed to send capture");
        else
            _me->ui_->status->showMessage("Sent capture");
    }) < 0)
    {
        ui_->status->showMessage("Failed to finish capture");
    }
}

/// called when the clearScreen button is clicked
void Caster::onClearScreen()
{
    image_->clearOverlays();
}

/// handles the result of a raw data request
/// @param[in] sz size of the raw data available, or status if not available
void Caster::rawData(int sz)
{
    if (sz < 0)
        ui_->status->showMessage("Error requesting raw data");
    else if (sz == 0)
        ui_->status->showMessage("No raw data currently buffered");
    else
    {
        rawData_.size_ = sz;
        ui_->download->setEnabled(true);
        ui_->status->showMessage(QStringLiteral("Raw data available: %1B").arg(rawData_.size_));
    }
}

/// called when the request raw data button is clicked
/// @note this can only be used while imaging is frozen
void Caster::onRequest()
{
    if (!connected_)
        return;

    if (castRequestRawData(0, 0, ui_->lzo->isChecked() ? 1 : 0, [](int sz, const char*)
    {
        _me->rawData(sz);
    }) < 0)
        ui_->status->showMessage("Raw data request failed");
}

/// called when the request download button is clicked
/// @note this can only be used once a raw data request has been made
void Caster::onDownload()
{
    if (!connected_)
        return;

    if (rawData_.size_)
    {
        rawData_.file_ = QFileDialog::getSaveFileName(this, QStringLiteral("Save Raw Data"), QDir::homePath() + QLatin1Char('/') + "raw_data.tar", QStringLiteral("(*.tar)"));
        if (rawData_.file_.isEmpty())
            return;

        setProgress(0);

        rawData_.data_.resize(rawData_.size_);
        rawData_.ptr_ = rawData_.data_.data();

        if (castReadRawData((void**)(&rawData_.ptr_), [](int ret)
        {
            // call is complete, post event to manage actual storage
            QApplication::postEvent(_me, new event::RawData(ret < 0 ? false : true));
        }) < 0)
            ui_->status->showMessage("Raw data download failed");
    }
}

/// called when the raw data download is ready
/// @param[in] success the success of downloading the data
/// @return success of the call
bool Caster::rawDataReady(bool success)
{
    if (!success)
    {
        ui_->status->showMessage("Error downloading raw data");
        return false;
    }
    else
    {
        QFile f(rawData_.file_);
        if (!f.open(QIODevice::WriteOnly))
        {
            ui_->status->showMessage("Error opening requested file");
            return false;
        }
        f.write(rawData_.data_);
        f.close();
        ui_->status->showMessage("Successfully downloaded data");
    }

    return true;
}

/// called when a new imu data been sent
/// @param[in] imu the imu data if valid
void Caster::newImuData(const QQuaternion& imu)
{
    if (!imu.isNull())
    {
        render_->update(imu);
        ui_->imuData->setText(QStringLiteral("Collected %1 IMU Samples").arg(++imuSamples_));
    }
}



================================================
FILE: examples/caster_qt/caster.h
================================================
#pragma once

namespace Ui
{
    class Caster;
}

class ProbeRender;

#define IMAGE_EVENT     static_cast<QEvent::Type>(QEvent::User + 1)
#define PRESCAN_EVENT   static_cast<QEvent::Type>(QEvent::User + 2)
#define RF_EVENT        static_cast<QEvent::Type>(QEvent::User + 3)
#define SPECTRUM_EVENT  static_cast<QEvent::Type>(QEvent::User + 4)
#define FREEZE_EVENT    static_cast<QEvent::Type>(QEvent::User + 5)
#define BUTTON_EVENT    static_cast<QEvent::Type>(QEvent::User + 6)
#define ERROR_EVENT     static_cast<QEvent::Type>(QEvent::User + 7)
#define PROGRESS_EVENT  static_cast<QEvent::Type>(QEvent::User + 8)
#define RAWDATA_EVENT   static_cast<QEvent::Type>(QEvent::User + 9)
#define IMU_EVENT       static_cast<QEvent::Type>(QEvent::User + 10)

namespace event
{
    /// wrapper for new image events that can be posted from the api callbacks
    class Image : public QEvent
    {
    public:
        /// default constructor
        /// @param[in] data the image data
        /// @param[in] w the image width
        /// @param[in] h the image height
        /// @param[in] bpp the image bits per pixel
        /// @param[in] sz total size of the image
        Image(QEvent::Type evt, const void* data, long long int tm, int w, int h, int bpp, int sz, const QQuaternion& imu)
            : QEvent(evt), data_(data), tm_(tm), width_(w), height_(h), bpp_(bpp), size_(sz), imu_(imu) { }

        const void* data_;  ///< pointer to the image data
        long long int tm_;  ///< timestamp
        int width_;         ///< width of the image
        int height_;        ///< height of the image
        int bpp_ ;          ///< bits per pixel
        int size_;          ///< total size of the image
        QQuaternion imu_;   ///< latest imu position
    };

    /// wrapper for new rf events that can be posted from the api callbacks
    class RfImage : public Image
    {
    public:
        /// default constructor
        /// @param[in] data the rf data
        /// @param[in] l # of rf lines
        /// @param[in] s # of samples per line
        /// @param[in] bps bits per sample
        /// @param[in] sz size of data in bytes
        /// @param[in] lateral lateral spacing between lines
        /// @param[in] axial sample size
        RfImage(const void* data, long long int tm, int l, int s, int bps, int sz, double lateral, double axial) : Image(RF_EVENT, data, tm, l, s, bps, sz, {}), lateral_(lateral), axial_(axial) { }

        double lateral_;    ///< spacing between each line
        double axial_;      ///< sample size
    };

    /// wrapper for new spectrum events that can be posted from the api callbacks
    class Spectrum : public Image
    {
    public:
        /// default constructor
        /// @param[in] data the image data
        /// @param[in] l the # of spectrum lines
        /// @param[in] s # of samples per line
        /// @param[in] bps bits per sample
        /// @param[in] sz size of the image in bytes
        Spectrum(const void* data, int l, int s, int bps, int sz, double period, double mps, double vps, bool pw) : Image(SPECTRUM_EVENT, data, 0, l, s, bps, sz, {}),
            period_(period), micronsPerSample_(mps), velocityPerSample_(vps), pw_(pw) { }

        double period_;             ///< line acquisition period in seconds
        double micronsPerSample_;   ///< microns per pixel/sample in an m spectrum
        double velocityPerSample_;  ///< velocity in m/s per pixel/sample in a pw spectrum
        bool pw_;                   ///< flag specifying the data is pw and not m
    };

    /// wrapper for new imu data events that can be posted from the api callbacks
    class Imu : public QEvent
    {
    public:
        /// default constructor
        /// @param[in] imu latest imu data
        explicit Imu(const QQuaternion& imu) : QEvent(IMU_EVENT), imu_(imu) { }

        QQuaternion imu_;   ///< latest imu position
    };

    /// wrapper for freeze events that can be posted from the api callbacks
    class Freeze : public QEvent
    {
    public:
        /// default constructor
        /// @param[in] frozen the freeze state
        explicit Freeze(bool frozen) : QEvent(FREEZE_EVENT), frozen_(frozen) { }

        bool frozen_;   ///< the freeze state
    };

    /// wrapper for button press events that can be posted from the api callbacks
    class Button : public QEvent
    {
    public:
        /// default constructor
        /// @param[in] btn the button pressed
        /// @param[in] clicks # of clicks
        Button(int btn, int clicks) : QEvent(BUTTON_EVENT), button_(btn), clicks_(clicks) { }

        int button_;    ///< button pressed, 0 = up, 1 = down
        int clicks_;    ///< # of clicks
    };

    /// wrapper for error events that can be posted from the api callbacks
    class Error : public QEvent
    {
    public:
        /// default constructor
        /// @param[in] err the error message
        explicit Error(const QString& err) : QEvent(ERROR_EVENT), error_(err) { }

        QString error_;     ///< the error message
    };

    /// wrapper for progress events that can be posted from the api callbacks
    class Progress : public QEvent
    {
    public:
        /// default constructor
        /// @param[in] progress the current progress
        explicit Progress(int progress) : QEvent(PROGRESS_EVENT), progress_(progress) { }

        int progress_;  ///< the current progress
    };

    /// wrapper for raw data completion events that can be posted from the api callbacks
    class RawData : public QEvent
    {
    public:
        /// default constructor
        /// @param[in] success success of downloading raw data
        explicit RawData(bool success) : QEvent(RAWDATA_EVENT), success_(success) { }

        bool success_;  ///< the current progress
    };
}

/// holds raw data information
class RawDataInfo
{
public:
    RawDataInfo() : size_(0), ptr_(nullptr) { }

    QString file_;
    int size_;
    QByteArray data_;
    char* ptr_;
};

class UltrasoundImage;
class RfSignal;

/// caster gui application
class Caster : public QMainWindow
{
    Q_OBJECT

public:
    explicit Caster(QWidget *parent = nullptr);
    ~Caster() override;

protected:
    virtual bool event(QEvent *event) override;
    virtual void closeEvent(QCloseEvent *event) override;

private:
    void newProcessedImage(const void* img, int w, int h, int bpp, int sz, const QQuaternion& imu);
    void newPrescanImage(const void* img, int w, int h, int bpp, int sz);
    void newRfData(const void* rfdata, int l, int s, int bps, double lateral, double axial);
    void newMSpectrum(const void* rfdata, int l, int s, int bps, double period, double micronsPerSample);
    void newPwSpectrum(const void* rfdata, int l, int s, int bps, double period, double velocityPerSample);
    void setFreeze(bool en);
    void onButton(int btn, int clicks);
    void setProgress(int progress);
    void setError(const QString& err);
    bool rawDataReady(bool success);
    void rawData(int sz);
    void connected(int imagePort, int imuPort);
    void disconnected(bool res);
    void newImuData(const QQuaternion& imu);

public slots:
    void onConnect();
    void onFreeze();
    void onShallower();
    void onDeeper();
    void onRequest();
    void onDownload();
    void onAddLabel();
    void onAddTrace();
    void onCaptureImage();
    void onClearScreen();

private:
    void updateCaptureButtons();
    bool connected_;            ///< connection state
    bool frozen_;               ///< freeze state
    long long int lasttime_;    ///< timesetamp of last received frame
    uint32_t imuSamples_;       ///< keeps track of samples collected
    RawDataInfo rawData_;       ///< raw data attributes
    Ui::Caster *ui_;            ///< ui controls, etc.
    UltrasoundImage* image_;    ///< image display
    ProbeRender* render_;           ///< probe renderer
    RfSignal* signal_;          ///< rf signal display
    QImage prescan_;            ///< pre-scan converted image
    QTimer imageTimer_;         ///< timer to warn the user about the firewall
    std::unique_ptr<QSettings> settings_;   ///< persistent settings
};



================================================
FILE: examples/caster_qt/caster.pro
================================================
TARGET = caster_qt
TEMPLATE = app
QT += core widgets gui 3dextras
CONFIG += c++17 precompile_header
DEFINES += QT_DEPRECATED_WARNINGS
PRECOMPILED_HEADER = pch.h

# ensure to unpack the appropriate libs from the zip file into this folder
LIBPATH = $$PWD/../../lib
INCLUDEPATH += $$PWD/../../include
LIBS += -L$$LIBPATH/ -lcast

SOURCES += main.cpp caster.cpp display.cpp 3d.cpp
HEADERS += caster.h display.h 3d.h
FORMS += caster.ui

RESOURCES += \
    caster.qrc



================================================
FILE: examples/caster_qt/caster.qrc
================================================
<RCC>
    <qresource prefix="/">
        <file>res/cast.png</file>
        <file>res/c3.obj</file>
        <file>res/c3.mtl</file>
        <file>res/l15.obj</file>
        <file>res/l15.mtl</file>
        <file>res/l20.obj</file>
        <file>res/l20.mtl</file>
    </qresource>
</RCC>



================================================
FILE: examples/caster_qt/caster.ui
================================================
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Caster</class>
 <widget class="QMainWindow" name="Caster">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>621</width>
    <height>556</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Caster</string>
  </property>
  <widget class="QWidget" name="_central">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <layout class="QVBoxLayout" name="image"/>
    </item>
    <item>
     <spacer name="verticalSpacer">
      <property name="orientation">
       <enum>Qt::Orientation::Vertical</enum>
      </property>
      <property name="sizeHint" stdset="0">
       <size>
        <width>20</width>
        <height>40</height>
       </size>
      </property>
     </spacer>
    </item>
    <item>
     <widget class="QTabWidget" name="tabWidget">
      <property name="currentIndex">
       <number>0</number>
      </property>
      <widget class="QWidget" name="_main">
       <attribute name="title">
        <string>Main</string>
       </attribute>
       <layout class="QGridLayout" name="gridLayout">
        <item row="1" column="1">
         <widget class="QLineEdit" name="port">
          <property name="inputMask">
           <string>#####</string>
          </property>
          <property name="text">
           <string>5828</string>
          </property>
         </widget>
        </item>
        <item row="0" column="0">
         <widget class="QLabel" name="_ip">
          <property name="text">
           <string>IP Address</string>
          </property>
         </widget>
        </item>
        <item row="2" column="0">
         <widget class="QLabel" name="label">
          <property name="text">
           <string>SW Revision</string>
          </property>
         </widget>
        </item>
        <item row="0" column="1">
         <widget class="QLineEdit" name="ip">
          <property name="inputMask">
           <string>000.000.000.000</string>
          </property>
          <property name="text">
           <string>192.168.1.1</string>
          </property>
         </widget>
        </item>
        <item row="2" column="1">
         <widget class="QLabel" name="swRevMatch">
          <property name="frameShape">
           <enum>QFrame::Shape::StyledPanel</enum>
          </property>
          <property name="text">
           <string/>
          </property>
         </widget>
        </item>
        <item row="1" column="0">
         <widget class="QLabel" name="_port">
          <property name="text">
           <string>Port</string>
          </property>
         </widget>
        </item>
        <item row="4" column="1">
         <spacer name="verticalSpacer_3">
          <property name="orientation">
           <enum>Qt::Orientation::Vertical</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
            <width>20</width>
            <height>40</height>
           </size>
          </property>
         </spacer>
        </item>
        <item row="2" column="2">
         <widget class="QPushButton" name="shallower">
          <property name="enabled">
           <bool>false</bool>
          </property>
          <property name="text">
           <string>Shallower</string>
          </property>
         </widget>
        </item>
        <item row="3" column="2">
         <widget class="QPushButton" name="deeper">
          <property name="enabled">
           <bool>false</bool>
          </property>
          <property name="text">
           <string>Deeper</string>
          </property>
         </widget>
        </item>
        <item row="0" column="2">
         <widget class="QPushButton" name="connect">
          <property name="text">
           <string>Connect</string>
          </property>
         </widget>
        </item>
        <item row="1" column="2">
         <widget class="QPushButton" name="freeze">
          <property name="enabled">
           <bool>false</bool>
          </property>
          <property name="text">
           <string>Freeze</string>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="_rawdata">
       <attribute name="title">
        <string>Raw Data</string>
       </attribute>
       <layout class="QGridLayout" name="gridLayout_2">
        <item row="0" column="0">
         <widget class="QPushButton" name="request">
          <property name="enabled">
           <bool>false</bool>
          </property>
          <property name="text">
           <string>Request</string>
          </property>
         </widget>
        </item>
        <item row="3" column="0">
         <widget class="QCheckBox" name="lzo">
          <property name="text">
           <string>Use LZO Compression</string>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item row="2" column="0">
         <widget class="QProgressBar" name="progress">
          <property name="value">
           <number>0</number>
          </property>
         </widget>
        </item>
        <item row="1" column="0">
         <widget class="QPushButton" name="download">
          <property name="enabled">
           <bool>false</bool>
          </property>
          <property name="text">
           <string>Download...</string>
          </property>
         </widget>
        </item>
        <item row="4" column="0">
         <spacer name="verticalSpacer_2">
          <property name="orientation">
           <enum>Qt::Orientation::Vertical</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
            <width>20</width>
            <height>40</height>
           </size>
          </property>
         </spacer>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="_overlays">
       <attribute name="title">
        <string>Overlays</string>
       </attribute>
       <layout class="QGridLayout" name="gridLayout_3">
        <item row="0" column="0">
         <widget class="QLabel" name="label_2">
          <property name="text">
           <string>Text</string>
          </property>
         </widget>
        </item>
        <item row="0" column="1" colspan="3">
         <widget class="QLineEdit" name="labelText"/>
        </item>
        <item row="1" column="1" colspan="3">
         <widget class="QLabel" name="label_4">
          <property name="frameShape">
           <enum>QFrame::Shape::StyledPanel</enum>
          </property>
          <property name="text">
           <string>Use right mouse button to draw</string>
          </property>
         </widget>
        </item>
        <item row="2" column="1">
         <widget class="QPushButton" name="addTrace">
          <property name="text">
           <string>Add Trace</string>
          </property>
         </widget>
        </item>
        <item row="2" column="0">
         <widget class="QPushButton" name="addLabel">
          <property name="enabled">
           <bool>false</bool>
          </property>
          <property name="text">
           <string>Add Label</string>
          </property>
         </widget>
        </item>
        <item row="1" column="0">
         <widget class="QLabel" name="label_3">
          <property name="text">
           <string>Overlay</string>
          </property>
         </widget>
        </item>
        <item row="2" column="3">
         <widget class="QPushButton" name="clearScreen">
          <property name="text">
           <string>Clear Screen</string>
          </property>
         </widget>
        </item>
        <item row="2" column="2">
         <widget class="QPushButton" name="captureImage">
          <property name="enabled">
           <bool>false</bool>
          </property>
          <property name="text">
           <string>Capture Image</string>
          </property>
         </widget>
        </item>
        <item row="3" column="2">
         <spacer name="verticalSpacer_4">
          <property name="orientation">
           <enum>Qt::Orientation::Vertical</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
            <width>20</width>
            <height>40</height>
           </size>
          </property>
         </spacer>
        </item>
       </layout>
      </widget>
      <widget class="QWidget" name="_render">
       <attribute name="title">
        <string>3D</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_3">
        <item>
         <layout class="QVBoxLayout" name="render"/>
        </item>
        <item>
         <widget class="QLabel" name="imuData">
          <property name="maximumSize">
           <size>
            <width>16777215</width>
            <height>30</height>
           </size>
          </property>
          <property name="frameShape">
           <enum>QFrame::Shape::StyledPanel</enum>
          </property>
          <property name="text">
           <string/>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QStatusBar" name="status"/>
 </widget>
 <layoutdefault spacing="6" margin="11"/>
 <tabstops>
  <tabstop>ip</tabstop>
  <tabstop>port</tabstop>
  <tabstop>connect</tabstop>
  <tabstop>freeze</tabstop>
  <tabstop>shallower</tabstop>
  <tabstop>deeper</tabstop>
  <tabstop>tabWidget</tabstop>
  <tabstop>lzo</tabstop>
  <tabstop>download</tabstop>
  <tabstop>labelText</tabstop>
  <tabstop>addLabel</tabstop>
  <tabstop>clearScreen</tabstop>
  <tabstop>captureImage</tabstop>
  <tabstop>request</tabstop>
  <tabstop>addTrace</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>connect</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onConnect()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>478</x>
     <y>371</y>
    </hint>
    <hint type="destinationlabel">
     <x>264</x>
     <y>215</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>request</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onRequest()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>173</x>
     <y>413</y>
    </hint>
    <hint type="destinationlabel">
     <x>264</x>
     <y>229</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>download</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onDownload()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>347</x>
     <y>413</y>
    </hint>
    <hint type="destinationlabel">
     <x>264</x>
     <y>229</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>freeze</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onFreeze()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>412</x>
     <y>381</y>
    </hint>
    <hint type="destinationlabel">
     <x>264</x>
     <y>229</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>shallower</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onShallower()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>411</x>
     <y>327</y>
    </hint>
    <hint type="destinationlabel">
     <x>230</x>
     <y>217</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>deeper</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onDeeper()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>411</x>
     <y>358</y>
    </hint>
    <hint type="destinationlabel">
     <x>230</x>
     <y>217</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>addLabel</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onAddLabel()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>20</x>
     <y>20</y>
    </hint>
    <hint type="destinationlabel">
     <x>20</x>
     <y>20</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>addTrace</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onAddTrace()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>20</x>
     <y>20</y>
    </hint>
    <hint type="destinationlabel">
     <x>20</x>
     <y>20</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>captureImage</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onCaptureImage()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>20</x>
     <y>20</y>
    </hint>
    <hint type="destinationlabel">
     <x>20</x>
     <y>20</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>clearScreen</sender>
   <signal>clicked()</signal>
   <receiver>Caster</receiver>
   <slot>onClearScreen()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>20</x>
     <y>20</y>
    </hint>
    <hint type="destinationlabel">
     <x>20</x>
     <y>20</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <slots>
  <slot>onConnect()</slot>
  <slot>onRequest()</slot>
  <slot>onDownload()</slot>
  <slot>onFreeze()</slot>
  <slot>onShallower()</slot>
  <slot>onDeeper()</slot>
  <slot>onAddLabel()</slot>
  <slot>onAddTrace()</slot>
  <slot>onCaptureImage()</slot>
  <slot>onClearScreen()</slot>
 </slots>
</ui>



================================================
FILE: examples/caster_qt/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.25)

project(caster_qt LANGUAGES CXX)

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt6 REQUIRED COMPONENTS Core Gui 3DExtras Bluetooth Widgets)
message("Found Qt? ${Qt6_FOUND}")

find_library(CAST_SDK_BINARY cast PATHS ${CMAKE_SOURCE_DIR}/../../lib)
message("Clarius Cast SDK binary location: ${CAST_SDK_BINARY}")
add_library(CAST_SDK UNKNOWN IMPORTED)
set_target_properties(CAST_SDK PROPERTIES
    IMPORTED_LOCATION ${CAST_SDK_BINARY}
    INTERFACE_INCLUDE_DIRECTORIES ${CMAKE_SOURCE_DIR}/../../include
)

qt_add_executable(caster_qt
    3d.cpp
    3d.h
    caster.cpp
    caster.h
    caster.qrc
    caster.ui
    display.cpp
    display.h
    main.cpp
)

set_target_properties(caster_qt PROPERTIES
    WIN32_EXECUTABLE TRUE
    MACOSX_BUNDLE TRUE
    MACOSX_BUNDLE_INFO_PLIST ${CMAKE_SOURCE_DIR}/macos/Info.plist
    MACOSX_BUNDLE_GUI_IDENTIFIER "me.clarius.sdk.caster_qt"
)

target_precompile_headers(caster_qt PRIVATE pch.h)

target_link_libraries(caster_qt PRIVATE
    Qt::Core
    Qt::Gui
    Qt::3DExtras
    Qt::Widgets
    CAST_SDK
)



================================================
FILE: examples/caster_qt/display.cpp
================================================
#include "display.h"
#include <cast/cast.h>

namespace
{
    enum class AddTo
    {
        front,
        back
    };
}

/// default constructor
/// @param[in] parent the parent object
UltrasoundImage::UltrasoundImage(QWidget* parent) : QGraphicsView(parent), noImage_(false)
{
    QGraphicsScene* sc = new QGraphicsScene(this);
    setScene(sc);

    // initialize image to some arbitrary size
    image_ = QImage(320, 240, QImage::Format_ARGB32);
    image_.fill(Qt::black);
    setSceneRect(0, 0, image_.width(), image_.height());
    setViewportUpdateMode(QGraphicsView::FullViewportUpdate);

    overlayColor_ = QColor(255, 127, 80, 100);

    QSizePolicy p(QSizePolicy::Preferred, QSizePolicy::Preferred);
    p.setHeightForWidth(true);
    setSizePolicy(p);
}

/// loads a new image from raw data
/// @param[in] img the new image data
/// @param[in] w the image width
/// @param[in] h the image height
/// @param[in] bpp bits per pixel
/// @param[in] sz size of image in bytes
void UltrasoundImage::loadImage(const void* img, int w, int h, int bpp, int sz)
{
    // check for size match
    if (image_.width() != w || image_.height() != h)
        return;

    // set the image data
    // check that the size matches the dimensions (uncompressed)
    if (sz == (w * h * (bpp / 8)))
        std::memcpy(image_.bits(), img, w * h * (bpp / 8));
    // try to load jpeg
    else
        image_.loadFromData(static_cast<const uchar*>(img), sz, "JPG");

    // redraw
    scene()->invalidate();
}

namespace
{
    QGraphicsItem* createLabel(const QString& text, QGraphicsScene* scenePtr, const QPointF& startPos)
    {
        QGraphicsSimpleTextItem* childText = scenePtr->addSimpleText(text);
        childText->setBrush(Qt::white);
        const QSizeF textSize = childText->boundingRect().size();
        const qreal halfHeight = textSize.height() / 2.0;
        const QSizeF rectSize = textSize + QSizeF(halfHeight, halfHeight);
        const QPointF topLeft = startPos - QPointF(rectSize.width(), rectSize.height()) / 2.0;
        QGraphicsRectItem* child = scenePtr->addRect(QRectF(topLeft, rectSize), QPen(), QBrush(QColor(0, 0, 0, 127)));
        childText->setParentItem(child);
        childText->setPos(topLeft + QPointF(halfHeight / 2.0, halfHeight / 2.0));
        return child;
    }
    QPointF getCenterPos(QGraphicsItem* item)
    {
        return item->boundingRect().center() + item->scenePos();
    }
    class CaliperItem : public QGraphicsRectItem
    {
    public:
        CaliperItem(const QRectF& rect, AddTo addto, std::shared_ptr<PointList> trace)
            : QGraphicsRectItem(rect)
            , addto_{addto}
            , trace_{std::move(trace)}
        {}
    protected:
        virtual QVariant itemChange(QGraphicsItem::GraphicsItemChange change, const QVariant& value) override
        {
            const QVariant result = QGraphicsRectItem::itemChange(change, value);
            if (change != QGraphicsItem::ItemPositionHasChanged)
                return result;

            const QPointF center = getCenterPos(this);
            QGraphicsItem* compareNearest = nullptr;
            QPointF pointNearest;
            if (!trace_->empty())
            {
                compareNearest = (addto_ == AddTo::front ? trace_->front() : trace_->back());
                pointNearest = getCenterPos(compareNearest);
            }
            QGraphicsScene* scenePtr = scene();
            if (trace_->size() > 1)
            {
                QGraphicsItem* compareNext = (addto_ == AddTo::front ? trace_->at(1) : trace_->at(trace_->size() - 2));
                const QPointF pointNext = getCenterPos(compareNext);
                if (QLineF(center, pointNext).length() < 20.0 &&
                    QLineF(center, pointNearest).length() < 20.0)
                {
                    scenePtr->removeItem(compareNearest);
                    delete compareNearest;
                    compareNearest = nullptr;
                    if (addto_ == AddTo::front)
                    {
                        trace_->pop_front();
                    }
                    else
                    {
                        trace_->pop_back();
                    }
                    return result;
                }
            }
            if (compareNearest && QLineF(center, pointNearest).length() < 20.0)
                return result;
            QGraphicsItem* newItem = scenePtr->addRect(QRectF(center - QPointF(1.0, 1.0), QSizeF(2.0, 2.0)), QPen(QColor(0, 255, 0)), QBrush(QColor(0, 255, 0)));
            if (addto_ == AddTo::front)
            {
                trace_->push_front(newItem);
            }
            else
            {
                trace_->push_back(newItem);
            }
            scenePtr->invalidate();
            return result;
        }
    private:
        AddTo addto_;
        std::shared_ptr<PointList> trace_;
    };
    QGraphicsRectItem* createCaliper(QGraphicsScene* scenePtr, const QSizeF& mainSize, AddTo addto, std::shared_ptr<PointList> trace)
    {
        const qreal height = qMin(mainSize.height(), mainSize.width()) / 10.0;
        const QPointF startPos(mainSize.width() / 2.0, mainSize.height() / 2.0);
        const QPointF topLeft = startPos - QPointF(height, height) / 2.0;
        const QRectF rect(topLeft, QSizeF(height, height));
        QGraphicsRectItem* child = new CaliperItem(rect, addto, trace);
        child->setPen(QPen(QColor(0, 0, 0, 0)));
        scenePtr->addItem(child);
        const QPointF center = rect.center();
        const qreal y1 = rect.top() + rect.height() / 3.0;
        const qreal y2 = rect.top() + rect.height() * 2.0 / 3.0;
        const QPen linePen(QColor(0, 255, 0));
        QGraphicsLineItem* line = scenePtr->addLine(QLineF(QPointF(center.x(), rect.top()), QPointF(center.x(), y1)), linePen);
        line->setParentItem(child);
        line = scenePtr->addLine(QLineF(QPointF(center.x(), y2), QPointF(center.x(), rect.bottom())), linePen);
        line->setParentItem(child);
        const qreal x1 = rect.left() + rect.width() / 3.0;
        const qreal x2 = rect.left() + rect.width() * 2.0 / 3.0;
        line = scenePtr->addLine(QLineF(QPointF(rect.left(), center.y()), QPointF(x1, center.y())), linePen);
        line->setParentItem(child);
        line = scenePtr->addLine(QLineF(QPointF(x2, center.y()), QPointF(rect.right(), center.y())), linePen);
        line->setParentItem(child);
        child->setFlag(QGraphicsItem::ItemIsMovable);
        child->setFlag(QGraphicsItem::ItemSendsGeometryChanges);
        return child;
    }
}

void UltrasoundImage::addLabel(const QString& text)
{
    const QSizeF mainSize = sceneRect().size();
    const QPointF startPos(mainSize.width() / 2.0, mainSize.height() / 2.0);
    QGraphicsItem* child = createLabel(text, scene(), startPos);
    child->setFlag(QGraphicsItem::ItemIsMovable);
    labels_.push_back(child);
    scene()->invalidate();
}

void UltrasoundImage::addTrace(const QString& text)
{
    Q_UNUSED(text)
    Trace trace;
    trace.points_ = std::make_shared<PointList>();
    const QSizeF mainSize = sceneRect().size();
    QGraphicsScene* scenePtr = scene();
    trace.first_ = createCaliper(scenePtr, mainSize, AddTo::front, trace.points_);
    trace.second_ = createCaliper(scenePtr, mainSize, AddTo::back, trace.points_);
    trace.text_ = text;
    const QRectF rect = trace.second_->boundingRect();
    QGraphicsItem* label = createLabel(text, scenePtr, QPointF(0, 0));
    label->setPos(QPointF(rect.right(), rect.top()) + QPointF(label->boundingRect().width() / 2.0, 0));
    label->setParentItem(trace.second_);
    traces_.push_back(trace);
    scenePtr->invalidate();
}

std::vector<LabelInfo> UltrasoundImage::getLabels() const
{
    std::vector<LabelInfo> result;
    for (QGraphicsItem* child : labels_)
    {
        const QList<QGraphicsItem*> textItems = child->childItems();
        if (textItems.isEmpty())
            continue;
        QGraphicsItem* textItem = textItems.front();
        if (textItem->type() != QGraphicsSimpleTextItem::Type)
            continue;
        const QRectF rect = child->boundingRect().translated(child->scenePos());
        result.emplace_back(static_cast<QGraphicsSimpleTextItem*>(textItem)->text(), rect);
    }
    return result;
}

std::vector<TraceInfo> UltrasoundImage::getTraces() const
{
    std::vector<TraceInfo> result;
    for (const Trace& trace : traces_)
    {
        QPolygonF points;
        points << getCenterPos(trace.first_);
        for (QGraphicsItem* pointItem : *trace.points_)
        {
            points << getCenterPos(pointItem);
        }
        points << getCenterPos(trace.second_);
        result.emplace_back(trace.text_, points);
    }
    return result;
}

QImage UltrasoundImage::overlayImage() const
{
    if (overlay_.isEmpty() || image_.size().isNull())
        return QImage{};

    QImage result(image_.size(), QImage::Format_Grayscale8);
    result.fill(Qt::black);
    QPen pen(Qt::white);
    pen.setWidth(20);
    pen.setCapStyle(Qt::RoundCap);
    pen.setJoinStyle(Qt::RoundJoin);
    QPainter painter(&result);
    painter.setPen(pen);
    painter.drawPath(overlay_);
    return result;
}

void UltrasoundImage::clearOverlays()
{
    QGraphicsScene* scenePtr = scene();
    for (QGraphicsItem* child : labels_)
    {
        scenePtr->removeItem(child);
        delete child;
    }
    labels_.clear();
    for (const Trace& trace : traces_)
    {
        scenePtr->removeItem(trace.first_);
        scenePtr->removeItem(trace.second_);
        delete trace.first_;
        delete trace.second_;
    }
    traces_.clear();
    overlay_.clear();
    // redraw
    scene()->invalidate();
}

/// handles resizing of the image view
/// @param[in] e the event to parse
void UltrasoundImage::resizeEvent(QResizeEvent* e)
{
    auto w = e->size().width(), h = e->size().height();

    setSceneRect(0, 0, w, h);
    castSetOutputSize(w, h);

    image_ = QImage(w, h, QImage::Format_ARGB32);
    image_.fill(Qt::black);

    overlay_.clear();

    QGraphicsView::resizeEvent(e);
}

void UltrasoundImage::mouseMoveEvent(QMouseEvent* event)
{
    QGraphicsView::mouseMoveEvent(event);

    if (event->buttons() == Qt::RightButton)
    {
        overlay_.moveTo(lastPoint_);
        overlay_.lineTo(event->pos());
        lastPoint_ = event->pos();
        // redraw
        scene()->invalidate();
    }
}

void UltrasoundImage::mousePressEvent(QMouseEvent* event)
{
    QGraphicsView::mousePressEvent(event);

    lastPoint_ = event->pos();
}

void UltrasoundImage::mouseReleaseEvent(QMouseEvent* event)
{
    QGraphicsView::mouseReleaseEvent(event);

    if (event->buttons() == Qt::RightButton)
    {
        overlay_.moveTo(lastPoint_);
        overlay_.lineTo(event->pos());
    }
    lastPoint_ = event->pos();

    // redraw
    scene()->invalidate();
}

/// calculates the ratio of the test image to determine the proper height ratio for width
/// @param[in] w the width of the widget
/// @return the appropriate height
int UltrasoundImage::heightForWidth(int w) const
{
    // keep a proper aspect 4:3 ratio
    double ratio = 3.0 / 4.0;
    return static_cast<int>(w * ratio);
}

/// size hint to keep the test image ratio
/// @return the size hint
QSize UltrasoundImage::sizeHint() const
{
    auto w = width();
    return QSize(w, heightForWidth(w));
}

/// creates a black background
/// @param[in] painter the drawing context
/// @param[in] r the rectangle to fill (the entire view)
void UltrasoundImage::drawBackground(QPainter* painter, const QRectF& r)
{
    QGraphicsView::drawBackground(painter, r);

    painter->fillRect(r, QBrush(Qt::black));

    if (!image_.isNull())
        painter->drawImage(r, image_);

    QColor overlayColor(overlayColor_);
    overlayColor.setAlpha(255);
    QPen pen(overlayColor);
    pen.setWidth(20);
    pen.setCapStyle(Qt::RoundCap);
    pen.setJoinStyle(Qt::RoundJoin);
    painter->setOpacity(overlayColor_.alphaF());
    painter->setPen(pen);
    painter->drawPath(overlay_);
    painter->setOpacity(1.0);

    if (noImage_)
    {
        painter->setFont(QFont(QStringLiteral("Arial"), 12));
        painter->setPen(Qt::white);
        painter->drawText(r, Qt::AlignCenter | Qt::AlignBottom, NO_IMAGE_STATEMENT);
    }
}

/// draws the target image
/// @param[in] painter the drawing context
void UltrasoundImage::drawForeground(QPainter* painter, const QRectF& r)
{
    QGraphicsView::drawForeground(painter, r);
}

/// default constructor
/// @param[in] parent the parent object
RfSignal::RfSignal(QWidget* parent) : QGraphicsView(parent), zoom_(0.1)
{
    QGraphicsScene* sc = new QGraphicsScene(this);
    setScene(sc);
    setVisible(false);

    setSceneRect(0, 0, width(), height());

    QSizePolicy p(QSizePolicy::Preferred, QSizePolicy::Preferred);
    p.setHeightForWidth(true);
    setSizePolicy(p);
}

/// loads new rf signal
/// @param[in] rf the new rf data
/// @param[in] l # of rf lines
/// @param[in] s # of samples per line
/// @param[in] ss sample size in bytes
void RfSignal::loadSignal(const void* rf, int l, int s, int ss)
{
    if (!rf || !l || !s || ss != 2)
        return;

    if (!isVisible())
        setVisible(true);

    // pick the center line to display
    signal_.clear();
    const int16_t* buf = static_cast<const int16_t*>(rf) + ((l / 2) * s);
    for (auto i = 0; i < s; i++)
        signal_.push_back(*buf++);

    // redraw
    scene()->invalidate();
}

/// sets the zoom scaling to display the rf signal
/// @param[in] zoom the zoom percentage
void RfSignal::setZoom(int zoom)
{
    zoom_ = (static_cast<qreal>(zoom) / 100.0);
}

/// handles resizing of the image view
/// @param[in] e the event to parse
void RfSignal::resizeEvent(QResizeEvent* e)
{
    auto w = e->size().width(), h = e->size().height();
    setSceneRect(0, 0, w, h);
    QGraphicsView::resizeEvent(e);
}

/// calculates the ratio of the test image to determine the proper height ratio for width
/// @param[in] w the width of the widget
/// @return the appropriate height
int RfSignal::heightForWidth(int w) const
{
    // keep 4:1 aspect ratio
    double ratio = 1.0 / 4.0;
    return static_cast<int>(w * ratio);
}

/// size hint to keep the test image ratio
/// @return the size hint
QSize RfSignal::sizeHint() const
{
    auto w = width();
    return QSize(w, heightForWidth(w));
}

/// creates a black background
/// @param[in] painter the drawing context
/// @param[in] r the rectangle to fill (the entire view)
void RfSignal::drawBackground(QPainter* painter, const QRectF& r)
{
    painter->fillRect(r, QBrush(Qt::black));
    QGraphicsView::drawBackground(painter, r);
}

/// draws the rf signal
/// @param[in] painter the drawing context
/// @param[in] r the view rectangle
void RfSignal::drawForeground(QPainter* painter, const QRectF& r)
{
    if (!signal_.isEmpty())
    {
        painter->setPen(QColor(96, 96, 0));
        qreal x = 0, baseline = r.height() / 2;
        double sampleSize = static_cast<double>(r.width()) / static_cast<double>(signal_.size());
        QPointF p(x, baseline);
        for (auto s : signal_)
        {
            qreal y = s * zoom_;
            QPointF pt(x + sampleSize, baseline + y);
            painter->drawLine(p, pt);
            p = pt;
            x = x + sampleSize;
        }
    }
}



================================================
FILE: examples/caster_qt/display.h
================================================
#pragma once

#define NO_IMAGE_STATEMENT QStringLiteral("No Image? Check the O/S Firewall Settings")

#include <deque>

struct LabelInfo
{
    explicit LabelInfo(const QString& text, const QRectF& rect)
        : text_(text), rect_(rect)
    {}
    QString text_;
    QRectF rect_;
};

struct TraceInfo
{
    explicit TraceInfo(const QString& text, const QPolygonF& points)
        : text_(text), points_(points)
    {}
    QString text_;
    QPolygonF points_;
};

using PointList = std::deque<QGraphicsItem*>;

/// ultrasound image display
class UltrasoundImage : public QGraphicsView
{
    Q_OBJECT
public:
    explicit UltrasoundImage(QWidget*);

    void loadImage(const void* img, int w, int h, int bpp, int sz);
    void setNoImage(bool en) { noImage_ = en; }
    void addLabel(const QString& text);
    void addTrace(const QString& text);
    void clearOverlays();
    QImage overlayImage() const;
    QColor overlayColor() const { return overlayColor_; }
    std::vector<LabelInfo> getLabels() const;
    std::vector<TraceInfo> getTraces() const;

protected:
    virtual void drawForeground(QPainter*, const QRectF&) override;
    virtual void drawBackground(QPainter*, const QRectF&) override;
    virtual void mouseMoveEvent(QMouseEvent* event) override;
    virtual void mousePressEvent(QMouseEvent* event) override;
    virtual void mouseReleaseEvent(QMouseEvent* event) override;
    virtual void resizeEvent(QResizeEvent* e) override;
    virtual int heightForWidth(int w) const override;
    virtual QSize sizeHint() const override;

private:
    struct Trace
    {
        QGraphicsRectItem* first_;
        QGraphicsRectItem* second_;
        QString text_;
        std::shared_ptr<PointList> points_;
    };

    bool noImage_;  ///< no image flag for potential firewall issues
    QImage image_;  ///< the image buffer
    QPainterPath overlay_; ///< user overlay
    QColor overlayColor_; ///< overlay color
    QPoint lastPoint_;
    std::vector<QGraphicsItem*> labels_;
    std::vector<Trace> traces_;
};

/// rf signal display
class RfSignal : public QGraphicsView
{
    Q_OBJECT
public:
    explicit RfSignal(QWidget*);

    void loadSignal(const void* rf, int l, int s, int ss);
    void setZoom(int zoom);

protected:
    virtual void drawForeground(QPainter*, const QRectF&) override;
    virtual void drawBackground(QPainter*, const QRectF&) override;

    virtual void resizeEvent(QResizeEvent* e) override;
    virtual int heightForWidth(int w) const override;
    virtual QSize sizeHint() const override;

private:
    QVector<int16_t> signal_;   ///< the rf signal
    qreal zoom_;                ///< zoom level
};



================================================
FILE: examples/caster_qt/main.cpp
================================================
#include "caster.h"
#include <memory>
#include <cast/cast.h>
#include <iostream>

static std::unique_ptr<Caster> _caster;
static std::vector<char> _image;
static std::vector<char> _prescanImage;
static std::vector<char> _spectrum;
static std::vector<char> _rfData;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    QCoreApplication::setOrganizationName(QStringLiteral("Clarius"));
    QCoreApplication::setOrganizationDomain(QStringLiteral("clarius.com"));
    QCoreApplication::setApplicationName(QStringLiteral("Cast Demo"));

    _caster = std::make_unique<Caster>();
    const int width  = 640; // Width of the rendered image
    const int height = 480; // Height of the rendered image

    auto storeDir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation).toLocal8Bit();
    auto initParams = castDefaultInitParams();
    initParams.args.argc = argc;
    initParams.args.argv = argv;
    initParams.storeDir = storeDir.constData();
    initParams.width = width;
    initParams.height = height;

    initParams.newProcessedImageFn =
        [](const void* img, const CusProcessedImageInfo* nfo, int npos, const CusPosInfo* pos)
        {
            int sz = nfo->imageSize;
            // we need to perform a deep copy of the image data since we have to post the event (yes this happens a lot with this api)
            if (_image.size() < static_cast<size_t>(sz))
                _image.resize(sz);
            std::memcpy(_image.data(), img, sz);
            QQuaternion imu;
            imu.setScalar(0.0);
            if (npos && pos)
                imu = QQuaternion(static_cast<float>(pos[0].qw), static_cast<float>(pos[0].qx), static_cast<float>(pos[0].qy), static_cast<float>(pos[0].qz));

            QApplication::postEvent(_caster.get(), new event::Image(IMAGE_EVENT, _image.data(), nfo->tm, nfo->width, nfo->height, nfo->bitsPerPixel, sz, imu));
        };

    initParams.newRawImageFn =
        [](const void* data, const CusRawImageInfo* nfo, int, const CusPosInfo*)
        {
            // we need to perform a deep copy of the image data since we have to post the event (yes this happens a lot with this api)
            int sz = nfo->lines * nfo->samples * (nfo->bitsPerSample / 8);
            if (nfo->rf)
            {
                if (_rfData.size() < static_cast<size_t>(sz))
                    _rfData.resize(sz);
                std::memcpy(_rfData.data(), data, sz);
                QApplication::postEvent(_caster.get(), new event::RfImage(_rfData.data(), nfo->tm, nfo->lines, nfo->samples, nfo->bitsPerSample, sz, nfo->lateralSize, nfo->axialSize));
            }
            else
            {
                // image may be a jpeg, adjust the size
                if (nfo->jpeg)
                    sz = nfo->jpeg;
                if (_prescanImage.size() < static_cast<size_t>(sz))
                    _prescanImage.resize(sz);
                std::memcpy(_prescanImage.data(), data, sz);
                QApplication::postEvent(_caster.get(), new event::Image(PRESCAN_EVENT, _prescanImage.data(), nfo->tm, nfo->lines, nfo->samples, nfo->bitsPerSample, sz, {}));
            }
        };

    initParams.newSpectralImageFn =
        [](const void* img, const CusSpectralImageInfo* nfo)
        {
            // we need to perform a deep copy of the image data since we have to post the event (yes this happens a lot with this api)
            int sz = nfo->lines * nfo->samples * (nfo->bitsPerSample / 8);
            if (_spectrum.size() < static_cast<size_t>(sz))
                _spectrum.resize(sz);
            std::memcpy(_spectrum.data(), img, sz);

            QApplication::postEvent(_caster.get(), new event::Spectrum(_spectrum.data(), nfo->lines, nfo->samples, nfo->bitsPerSample, sz, nfo->period,
                                                                       nfo->micronsPerSample, nfo->velocityPerSample, nfo->pw ? true : false));
        };

    initParams.newImuDataFn =
        [](const CusPosInfo* pos)
        {
            QQuaternion imu;
            if (pos)
                imu = QQuaternion(static_cast<float>(pos->qw), static_cast<float>(pos->qx), static_cast<float>(pos->qy), static_cast<float>(pos->qz));
            QApplication::postEvent(_caster.get(), new event::Imu(imu));
        };

    initParams.freezeFn =
        [](int frozen)
        {
            // post event here, as the gui (statusbar) will be updated directly, and it needs to come from the application thread
            QApplication::postEvent(_caster.get(), new event::Freeze(frozen ? true : false));
        };

    initParams.buttonFn =
        [](CusButton btn, int clicks)
        {
            // post event here, as the gui (statusbar) will be updated directly, and it needs to come from the application thread
            QApplication::postEvent(_caster.get(), new event::Button(btn, clicks));
        };

    initParams.progressFn =
        [](int progress)
        {
            // post event here, as the gui (proress bar) will be updated directly, and it needs to come from the application thread
            QApplication::postEvent(_caster.get(), new event::Progress(progress));
        };

    initParams.errorFn =
        [](const char* err)
        {
            // post event here, as the gui (statusbar) will be updated directly, and it needs to come from the application thread
            QApplication::postEvent(_caster.get(), new event::Error(err));
        };

    if (castInit(&initParams) != CUS_SUCCESS)
    {
        qDebug() << "error initializing listener";
        return -1;
    }

    _caster->show();
    const int result = a.exec();
    castDestroy();
    _caster.reset();
    return result;
}



================================================
FILE: examples/caster_qt/pch.h
================================================
#ifndef PCH_H
#define PCH_H

#ifdef __clang__
    #pragma clang diagnostic push
#elif _MSC_VER
    #pragma warning(push)
    #pragma warning(disable: 4251)
    #pragma warning(disable: 4127)
    #pragma warning(disable: 4512)
    #pragma warning(disable: 4510)
    #pragma warning(disable: 4610)
    #pragma warning(disable: 4458)
    #pragma warning(disable: 4800)
#endif

#include <QtWidgets/QtWidgets>
#include <QtGui/QtGui>
#include <Qt3DCore/Qt3DCore>
#include <Qt3DRender/Qt3DRender>
#include <Qt3DExtras/Qt3DExtras>

#ifdef __clang__
    #pragma clang diagnostic pop
#elif _MSC_VER
    #pragma warning(pop)
#endif

#endif



================================================
FILE: examples/caster_qt/macos/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>

	<key>CFBundleName</key>
	<string>caster_qt</string>
	<key>CFBundleIdentifier</key>
	<string></string>
	<key>CFBundleExecutable</key>
	<string>caster_qt</string>

	<key>CFBundleVersion</key>
	<string>1.0.0</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0</string>

	<key>LSMinimumSystemVersion</key>
	<string></string>

	<key>NSHumanReadableCopyright</key>
	<string></string>

	<key>CFBundleIconFile</key>
	<string></string>

	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleAllowMixedLocalizations</key>
	<true/>

	<key>NSPrincipalClass</key>
	<string>NSApplication</string>

	<key>NSSupportsAutomaticGraphicsSwitching</key>
	<true/>

</dict>
</plist>



================================================
FILE: examples/caster_qt/res/c3.mtl
================================================
﻿
newmtl Material-0
Kd 0.7 0.7 0.7 
Ka 0.01 0.01 0.01 
Ks 0.01 0.01 0.01 
d 1

newmtl Mtl
Kd 0.792157 0.819608 0.933333 
Ka 0 0 0 
Ks 0.396078 0.409804 0.466667 
d 1

newmtl Mtl1
Kd 1 1 1 
Ka 0 0 0 
Ks 0.5 0.5 0.5 
d 1

newmtl Mtl2
Kd 1 0.815686 0.584314 
Ka 0 0 0 
Ks 0.5 0.407843 0.292157 
d 1

newmtl Mtl3
Kd 0.501961 0.501961 0.501961 
Ka 0 0 0 
Ks 0.25098 0.25098 0.25098 
d 1

newmtl Mtl4
Kd 0.25098 0.25098 0.25098 
Ka 0 0 0 
Ks 0.12549 0.12549 0.12549 
d 1



================================================
FILE: examples/caster_qt/res/l15.mtl
================================================
﻿
newmtl Material-0
Kd 0.7 0.7 0.7 
Ka 0.01 0.01 0.01 
Ks 0.01 0.01 0.01 
d 1

newmtl Mtl
Kd 0.792157 0.819608 0.933333 
Ka 0 0 0 
Ks 0.396078 0.409804 0.466667 
d 1

newmtl Mtl1
Kd 0.501961 1 0.501961 
Ka 0 0 0 
Ks 0.25098 0.5 0.25098 
d 1

newmtl Mtl2
Kd 1 1 1 
Ka 0 0 0 
Ks 0.5 0.5 0.5 
d 1

newmtl Mtl3
Kd 0.501961 0.501961 0.501961 
Ka 0 0 0 
Ks 0.25098 0.25098 0.25098 
d 1

newmtl Mtl4
Kd 0.25098 0.25098 0.25098 
Ka 0 0 0 
Ks 0.12549 0.12549 0.12549 
d 1



================================================
FILE: examples/caster_qt/res/l20.mtl
================================================
﻿
newmtl Material-0
Kd 0.7 0.7 0.7 
Ka 0.01 0.01 0.01 
Ks 0.01 0.01 0.01 
d 1

newmtl Mtl1
Kd 0.501961 1 0.501961 
Ka 0 0 0 
Ks 0.25098 0.5 0.25098 
d 1

newmtl Mtl
Kd 0.792157 0.819608 0.933333 
Ka 0 0 0 
Ks 0.396078 0.409804 0.466667 
d 1

newmtl Mtl2
Kd 1 1 1 
Ka 0 0 0 
Ks 0.5 0.5 0.5 
d 1

newmtl Mtl3
Kd 0.501961 0.501961 0.501961 
Ka 0 0 0 
Ks 0.25098 0.25098 0.25098 
d 1

newmtl Mtl4
Kd 0.25098 0.25098 0.25098 
Ka 0 0 0 
Ks 0.12549 0.12549 0.12549 
d 1

newmtl Mtl5
Kd 1 0.788235 0.313726 
Ka 0 0 0 
Ks 0.5 0.394118 0.156863 
d 1



================================================
FILE: examples/python/README.md
================================================
# Cast API with Python

A Python wrapper (`pyclariuscast`) has been created to help with getting programs running more quickly.

Examples:
- **pycaster**: a command line tool to connect and stream images. Support for writing out images using PIL.
- **pysidecaster**: a Qt-based graphical program to connect and stream/view images. Uses PySide6 for usage of the Qt libraries.

Executing under Linux:
- Install Pillow (latest PIL library) and PySide6 using pip.
- Copy the python programs to the extracted libs folder (where `pyclariuscast.so` and `libcast.so` are placed).
- Execute: python3 `<example file>.py`



================================================
FILE: examples/python/pycaster.py
================================================
#!/usr/bin/env python

import argparse
import ctypes
import os.path
import sys

if sys.platform.startswith("linux"):
    libcast_handle = ctypes.CDLL("./libcast.so", ctypes.RTLD_GLOBAL)._handle  # load the libcast.so shared library
    pyclariuscast = ctypes.cdll.LoadLibrary("./pyclariuscast.so")  # load the pyclariuscast.so shared library

import pyclariuscast
from PIL import Image

printStream = True


## called when a new processed image is streamed
# @param image the scan-converted image data
# @param width width of the image in pixels
# @param height height of the image in pixels
# @param sz full size of image
# @param micronsPerPixel microns per pixel
# @param timestamp the image timestamp in nanoseconds
# @param angle acquisition angle for volumetric data
# @param imu inertial data tagged with the frame
def newProcessedImage(image, width, height, sz, micronsPerPixel, timestamp, angle, imu):
    bpp = sz / (width * height)
    if printStream:
        print(
            f"image: {timestamp}, {width}x{height} @ {bpp} bpp, {micronsPerPixel:.2f} um/px, imu: {len(imu)} pts",
            end="\r",
        )
    if bpp == 4:
        img = Image.frombytes("RGBA", (width, height), image)
    else:
        img = Image.frombytes("L", (width, height), image)
    # img.save("processed_image.png")


## called when a new raw image is streamed
# @param image the raw pre scan-converted image data, uncompressed 8-bit or jpeg compressed
# @param lines number of lines in the data
# @param samples number of samples in the data
# @param bps bits per sample
# @param axial microns per sample
# @param lateral microns per line
# @param timestamp the image timestamp in nanoseconds
# @param jpg jpeg compression size if the data is in jpeg format
# @param rf flag for if the image received is radiofrequency data
# @param angle acquisition angle for volumetric data
def newRawImage(image, lines, samples, bps, axial, lateral, timestamp, jpg, rf, angle):
    # check the rf flag for radiofrequency data vs raw grayscale
    # raw grayscale data is non scan-converted and in polar co-ordinates
    # print(
    #    "raw image: {0}, {1}x{2} @ {3} bps, {4:.2f} um/s, {5:.2f} um/l, rf: {6}".format(
    #        timestamp, lines, samples, bps, axial, lateral, rf
    #    ), end = "\r"
    # )
    # if jpg == 0:
    #    img = Image.frombytes("L", (samples, lines), image, "raw")
    # else:
    #    # note! this probably won't work unless a proper decoder is written
    #    img = Image.frombytes("L", (samples, lines), image, "jpg")
    # img.save("raw_image.jpg")
    return


## called when a new spectrum image is streamed
# @param image the spectral image
# @param lines number of lines in the spectrum
# @param samples number of samples per line
# @param bps bits per sample
# @param period line repetition period of spectrum
# @param micronsPerSample microns per sample for an m spectrum
# @param velocityPerSample velocity per sample for a pw spectrum
# @param pw flag that is true for a pw spectrum, false for an m spectrum
def newSpectrumImage(image, lines, samples, bps, period, micronsPerSample, velocityPerSample, pw):
    return


## called when a new imu data is streamed
# @param imu inertial data tagged with the frame
def newImuData(imu):
    return


## called when freeze state changes
# @param frozen the freeze state
def freezeFn(frozen):
    if frozen:
        print("\nimaging frozen")
    else:
        print("imaging running")


## called when a button is pressed
# @param button the button that was pressed
# @param clicks number of clicks performed
def buttonsFn(button, clicks):
    print(f"button pressed: {button}, clicks: {clicks}")


## main function
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--address", "-a", dest="ip", help="ip address of probe.", required=True)
    parser.add_argument("--port", "-p", dest="port", type=int, help="port of the probe", required=True)
    parser.add_argument("--width", "-w", dest="width", type=int, help="image output width in pixels")
    parser.add_argument("--height", "-ht", dest="height", type=int, help="image output height in pixels")
    parser.set_defaults(ip=None)
    parser.set_defaults(port=None)
    parser.set_defaults(width=640)
    parser.set_defaults(height=480)
    args = parser.parse_args()

    # uncomment to get documentation for pyclariuscast module
    # print(help(pyclariuscast))

    if not args.ip or not args.port or args.port < 0:
        print("one or more arguments are invalid")
        parser.print_usage()
        return

    # get home path
    path = os.path.expanduser("~/")

    # initialize
    cast = pyclariuscast.Caster(newProcessedImage, newRawImage, newSpectrumImage, newImuData, freezeFn, buttonsFn)
    ret = cast.init(path, args.width, args.height)
    if ret:
        print("initialization succeeded")
        ret = cast.connect(args.ip, args.port, "research")
        if ret:
            print(f"connected to {args.ip} on port {args.port}")
        else:
            print("connection failed")
            if sys.platform.startswith("linux"):
                # unload the shared library before destroying the cast object
                ctypes.CDLL("libc.so.6").dlclose(libcast_handle)
            cast.destroy()
            return
    else:
        print("initialization failed")
        return

    # input loop
    key = ""
    while key != "q" and key != "Q":
        key = input("press (q)->quit (a)->action (s)->stream (p)->param change: ")
        if key == "a" or key == "A":
            key = input("(f)->freeze (i)->capture image (c)->capture cine, (d/D)->depth, (g/G)->gain: ")
            if key == "f" or key == "F":
                cast.userFunction(1, 0)
            elif key == "i" or key == "I":
                cast.userFunction(2, 0)
            elif key == "c" or key == "C":
                cast.userFunction(3, 0)
            elif key == "d":
                cast.userFunction(4, 0)
            elif key == "D":
                cast.userFunction(5, 0)
            elif key == "g":
                cast.userFunction(6, 0)
            elif key == "G":
                cast.userFunction(7, 0)
        elif key == "d" or key == "D":
            ret = cast.disconnect()
            if ret:
                print("successful disconnect")
            else:
                print("disconnection failed")
        elif key == "s" or key == "S":
            global printStream
            printStream = not printStream
        elif key == "p" or key == "P":
            inp = input("enter: {parameter name} {value [float/true/false]}").split()
            if len(inp) != 2:
                print("please format as: {parameter name} {value [float/true/false]}")
            elif inp[1] == "true" or inp[1] == "false":
                cast.enableParam(inp[0], 1 if inp[1] == "true" else 0)
            elif "+" in inp[1]:
                cast.setPulse(inp[0], inp[1])
            else:
                cast.setParam(inp[0], float(inp[1]))

    cast.destroy()


if __name__ == "__main__":
    main()



================================================
FILE: examples/python/pyimu.py
================================================
#!/usr/bin/env python

import ctypes
import os.path
import sys

if sys.platform.startswith("linux"):
    libcast_handle = ctypes.CDLL("./libcast.so", ctypes.RTLD_GLOBAL)._handle  # load the libcast.so shared library
    pyclariuscast = ctypes.cdll.LoadLibrary("./pyclariuscast.so")  # load the pyclariuscast.so shared library

import pyclariuscast
from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.Qt3DCore import Qt3DCore
from PySide6.Qt3DExtras import Qt3DExtras
from PySide6.Qt3DRender import Qt3DRender
from PySide6.QtCore import QUrl, Slot
from PySide6.QtGui import QQuaternion, QVector3D


# custom event for handling change in freeze state
class FreezeEvent(QtCore.QEvent):
    def __init__(self, frozen):
        super().__init__(QtCore.QEvent.User)
        self.frozen = frozen


# custom event for handling button presses
class ButtonEvent(QtCore.QEvent):
    def __init__(self, btn, clicks):
        super().__init__(QtCore.QEvent.Type(QtCore.QEvent.User + 1))
        self.btn = btn
        self.clicks = clicks


# custom event for handling new images
class ImageEvent(QtCore.QEvent):
    def __init__(self):
        super().__init__(QtCore.QEvent.Type(QtCore.QEvent.User + 2))


# manages custom events posted from callbacks, then relays as signals to the main widget
class Signaller(QtCore.QObject):
    freeze = QtCore.Signal(bool)
    button = QtCore.Signal(int, int)
    image = QtCore.Signal(float, float, float, float)
    qw = 0
    qx = 0
    qy = 0
    qz = 0

    def __init__(self):
        QtCore.QObject.__init__(self)
        self.usimage = QtGui.QImage()

    def event(self, evt):
        if evt.type() == QtCore.QEvent.User:
            self.freeze.emit(evt.frozen)
        elif evt.type() == QtCore.QEvent.Type(QtCore.QEvent.User + 1):
            self.button.emit(evt.btn, evt.clicks)
        elif evt.type() == QtCore.QEvent.Type(QtCore.QEvent.User + 2):
            self.image.emit(self.qw, self.qx, self.qy, self.qz)
        return True


# global required for the listen api callbacks
signaller = Signaller()


# 3d render class
class ScannerWindow(Qt3DExtras.Qt3DWindow):
    qw = 0.5
    qx = 0.5
    qy = -0.5
    qz = 0.5
    scannerTransform = Qt3DCore.QTransform()

    def __init__(self):
        super(ScannerWindow, self).__init__()

        # camera
        self.camera().lens().setPerspectiveProjection(50, 16 / 9, 0.1, 1000)
        self.camera().setPosition(QVector3D(0, 0, 30))
        self.camera().setViewCenter(QVector3D(0, 0, 0))

        # create scene from obj file
        self.createScene()
        self.setRootEntity(self.rootEntity)

    def updateAngle(self, qw, qx, qy, qz):
        self.qw = qw
        self.qx = qx
        self.qy = qy
        self.qz = qz
        self.addTransform()

    def addTransform(self):
        # correct orientation
        self.scannerTransform.setScale3D(QVector3D(100, 100, 100))
        self.orientation = QQuaternion(self.qw, self.qx, self.qy, self.qz)
        self.axisCorrection = QQuaternion.fromEulerAngles(0, 180, 90)
        self.modelCorrection = QQuaternion.fromEulerAngles(-90, 0, 90)
        self.modelRotation = self.orientation * self.axisCorrection
        self.correctedOrientation = self.modelCorrection * self.modelRotation
        self.scannerTransform.setRotation(self.correctedOrientation)
        self.scannerEntity.addComponent(self.scannerTransform)

    def createScene(self):
        self.rootEntity = Qt3DCore.QEntity()
        self.scannerEntity = Qt3DCore.QEntity(self.rootEntity)
        # QSceneLoader loads materials from scanner.mtl referenced in scanner.obj
        self.scanner = Qt3DRender.QSceneLoader(self.scannerEntity)
        self.scanner.setSource(QUrl.fromLocalFile("scanner.obj"))
        self.scannerEntity.addComponent(self.scanner)
        self.addTransform()


# main widget with controls and ui
class MainWidget(QtWidgets.QMainWindow):
    def __init__(self, cast, parent=None):
        QtWidgets.QMainWindow.__init__(self, parent)

        self.cast = cast

        # create central widget within main window
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)

        ip = QtWidgets.QLineEdit("192.168.1.1")
        ip.setInputMask("000.000.000.000")
        port = QtWidgets.QLineEdit("5828")
        port.setInputMask("00000")

        conn = QtWidgets.QPushButton("Connect")

        # try to connect/disconnect to/from the probe
        def tryConnect():
            if not cast.isConnected():
                if cast.connect(ip.text(), int(port.text()), "research"):
                    self.statusBar().showMessage("Connected")
                    conn.setText("Disconnect")
                else:
                    self.statusBar().showMessage(f"Failed to connect to {ip.text()}")
            elif cast.disconnect():
                self.statusBar().showMessage("Disconnected")
                conn.setText("Connect")
            else:
                self.statusBar().showMessage("Failed to disconnect")

        conn.clicked.connect(tryConnect)
        quit = QtWidgets.QPushButton("Quit")
        quit.clicked.connect(self.shutdown)

        # add widgets to layout
        self.scanner = ScannerWindow()
        scannerWidget = QtWidgets.QWidget.createWindowContainer(self.scanner)
        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(scannerWidget)
        layout.addWidget(ip)
        layout.addWidget(port)
        layout.addWidget(conn)
        layout.addWidget(quit)
        central.setLayout(layout)

        # connect signals
        signaller.freeze.connect(self.freeze)
        signaller.button.connect(self.button)
        signaller.image.connect(self.image)

        # get home path
        path = os.path.expanduser("~/")
        if cast.init(path, 640, 480):
            self.statusBar().showMessage("Initialized")
        else:
            self.statusBar().showMessage("Failed to initialize")

    # handles freeze messages
    @Slot(bool)
    def freeze(self, frozen):
        if frozen:
            self.statusBar().showMessage("Image Stopped")
        else:
            self.statusBar().showMessage("Image Running")

    # handles button messages
    @Slot(int, int)
    def button(self, btn, clicks):
        self.statusBar().showMessage(f"Button {btn} pressed w/ {clicks} clicks")

    # handles new images
    @Slot(float, float, float, float)
    def image(self, qw, qx, qy, qz):
        self.scanner.updateAngle(qw, qx, qy, qz)

    # handles shutdown
    @Slot()
    def shutdown(self):
        if sys.platform.startswith("linux"):
            # unload the shared library before destroying the cast object
            ctypes.CDLL("libc.so.6").dlclose(libcast_handle)
        self.cast.destroy()
        QtWidgets.QApplication.quit()


## called when a new processed image is streamed
# @param image the scan-converted image data
# @param width width of the image in pixels
# @param height height of the image in pixels
# @param bpp bits per pixel
# @param micronsPerPixel microns per pixel
# @param timestamp the image timestamp in nanoseconds
# @param angle acquisition angle for volumetric data
# @param imu imu data sets
def newProcessedImage(image, width, height, bpp, micronsPerPixel, timestamp, angle, imu):
    if len(imu) > 0:
        signaller.qw = imu[0].qw
        signaller.qx = imu[0].qx
        signaller.qy = imu[0].qy
        signaller.qz = imu[0].qz
        evt = ImageEvent()
        QtCore.QCoreApplication.postEvent(signaller, evt)


## called when a new raw image is streamed
# @param image the raw pre scan-converted image data, uncompressed 8-bit or jpeg compressed
# @param lines number of lines in the data
# @param samples number of samples in the data
# @param bps bits per sample
# @param axial microns per sample
# @param lateral microns per line
# @param timestamp the image timestamp in nanoseconds
# @param jpg jpeg compression size if the data is in jpeg format
# @param rf flag for if the image received is radiofrequency data
# @param angle acquisition angle for volumetric data
def newRawImage(image, lines, samples, bps, axial, lateral, timestamp, jpg, rf, angle):
    return


## called when a new spectrum image is streamed
# @param image the spectral image
# @param lines number of lines in the spectrum
# @param samples number of samples per line
# @param bps bits per sample
# @param period line repetition period of spectrum
# @param micronsPerSample microns per sample for an m spectrum
# @param velocityPerSample velocity per sample for a pw spectrum
# @param pw flag that is true for a pw spectrum, false for an m spectrum
def newSpectrumImage(image, lines, samples, bps, period, micronsPerSample, velocityPerSample, pw):
    return


## called when a new imu data is streamed
# @param imu inertial data tagged with the frame
def newImuData(imu):
    return


## called when freeze state changes
# @param frozen the freeze state
def freezeFn(frozen):
    evt = FreezeEvent(frozen)
    QtCore.QCoreApplication.postEvent(signaller, evt)


## called when a button is pressed
# @param button the button that was pressed
# @param clicks number of clicks performed
def buttonsFn(button, clicks):
    evt = ButtonEvent(button, clicks)
    QtCore.QCoreApplication.postEvent(signaller, evt)


## main function
def main():
    cast = pyclariuscast.Caster(newProcessedImage, newRawImage, newSpectrumImage, newImuData, freezeFn, buttonsFn)
    app = QtWidgets.QApplication(sys.argv)
    widget = MainWidget(cast)
    widget.resize(640, 480)
    widget.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()



================================================
FILE: examples/python/pysidecaster.py
================================================
#!/usr/bin/env python

import ctypes
import os.path
import sys
from pathlib import Path
from typing import Final

if sys.platform.startswith("linux"):
    libcast_handle = ctypes.CDLL("./libcast.so", ctypes.RTLD_GLOBAL)._handle  # load the libcast.so shared library
    pyclariuscast = ctypes.cdll.LoadLibrary("./pyclariuscast.so")  # load the pyclariuscast.so shared library

import pyclariuscast
from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import Slot

CMD_FREEZE: Final = 1
CMD_CAPTURE_IMAGE: Final = 2
CMD_CAPTURE_CINE: Final = 3
CMD_DEPTH_DEC: Final = 4
CMD_DEPTH_INC: Final = 5
CMD_GAIN_DEC: Final = 6
CMD_GAIN_INC: Final = 7
CMD_B_MODE: Final = 12
CMD_CFI_MODE: Final = 14


# custom event for handling change in freeze state
class FreezeEvent(QtCore.QEvent):
    def __init__(self, frozen):
        super().__init__(QtCore.QEvent.User)
        self.frozen = frozen


# custom event for handling button presses
class ButtonEvent(QtCore.QEvent):
    def __init__(self, btn, clicks):
        super().__init__(QtCore.QEvent.Type(QtCore.QEvent.User + 1))
        self.btn = btn
        self.clicks = clicks


# custom event for handling new images
class ImageEvent(QtCore.QEvent):
    def __init__(self):
        super().__init__(QtCore.QEvent.Type(QtCore.QEvent.User + 2))


# manages custom events posted from callbacks, then relays as signals to the main widget
class Signaller(QtCore.QObject):
    freeze = QtCore.Signal(bool)
    button = QtCore.Signal(int, int)
    image = QtCore.Signal(QtGui.QImage)

    def __init__(self):
        QtCore.QObject.__init__(self)
        self.usimage = QtGui.QImage()

    def event(self, evt):
        if evt.type() == QtCore.QEvent.User:
            self.freeze.emit(evt.frozen)
        elif evt.type() == QtCore.QEvent.Type(QtCore.QEvent.User + 1):
            self.button.emit(evt.btn, evt.clicks)
        elif evt.type() == QtCore.QEvent.Type(QtCore.QEvent.User + 2):
            self.image.emit(self.usimage)
        return True


# global required for the cast api callbacks
signaller = Signaller()


# draws the ultrasound image
class ImageView(QtWidgets.QGraphicsView):
    def __init__(self, cast):
        QtWidgets.QGraphicsView.__init__(self)
        self.cast = cast
        self.setScene(QtWidgets.QGraphicsScene())

    # set the new image and redraw
    def updateImage(self, img):
        self.image = img
        self.scene().invalidate()

    # saves a local image
    def saveImage(self):
        self.image.save(str(Path.home() / "Pictures/clarius_image.png"))

    # resize the scan converter, image, and scene
    def resizeEvent(self, evt):
        w = evt.size().width()
        h = evt.size().height()
        self.cast.setOutputSize(w, h)
        self.image = QtGui.QImage(w, h, QtGui.QImage.Format_ARGB32)
        self.image.fill(QtCore.Qt.black)
        self.setSceneRect(0, 0, w, h)

    # black background
    def drawBackground(self, painter, rect):
        painter.fillRect(rect, QtCore.Qt.black)

    # draws the image
    def drawForeground(self, painter, rect):
        if not self.image.isNull():
            painter.drawImage(rect, self.image)


# main widget with controls and ui
class MainWidget(QtWidgets.QMainWindow):
    def __init__(self, cast, parent=None):
        QtWidgets.QMainWindow.__init__(self, parent)

        self.cast = cast
        self.setWindowTitle("Clarius Cast Demo")

        # create central widget within main window
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)

        ip = QtWidgets.QLineEdit("192.168.1.1")
        ip.setInputMask("000.000.000.000")
        port = QtWidgets.QLineEdit("5828")
        port.setInputMask("00000")

        conn = QtWidgets.QPushButton("Connect")
        self.run = QtWidgets.QPushButton("Run")
        quit = QtWidgets.QPushButton("Quit")
        depthUp = QtWidgets.QPushButton("< Depth")
        depthDown = QtWidgets.QPushButton("> Depth")
        gainInc = QtWidgets.QPushButton("> Gain")
        gainDec = QtWidgets.QPushButton("< Gain")
        captureImage = QtWidgets.QPushButton("Capture Image")
        captureCine = QtWidgets.QPushButton("Capture Movie")
        saveImage = QtWidgets.QPushButton("Save Local")
        bMode = QtWidgets.QPushButton("B Mode")
        cfiMode = QtWidgets.QPushButton("Color Mode")

        # try to connect/disconnect to/from the probe
        def tryConnect():
            if not cast.isConnected():
                if cast.connect(ip.text(), int(port.text()), "research"):
                    self.statusBar().showMessage("Connected")
                    conn.setText("Disconnect")
                else:
                    self.statusBar().showMessage(f"Failed to connect to {ip.text()}")
            elif cast.disconnect():
                self.statusBar().showMessage("Disconnected")
                conn.setText("Connect")
            else:
                self.statusBar().showMessage("Failed to disconnect")

        # try to freeze/unfreeze
        def tryFreeze():
            if cast.isConnected():
                cast.userFunction(CMD_FREEZE, 0)

        # try depth up
        def tryDepthUp():
            if cast.isConnected():
                cast.userFunction(CMD_DEPTH_DEC, 0)

        # try depth down
        def tryDepthDown():
            if cast.isConnected():
                cast.userFunction(CMD_DEPTH_INC, 0)

        # try gain down
        def tryGainDec():
            if cast.isConnected():
                cast.userFunction(CMD_GAIN_DEC, 0)

        # try gain up
        def tryGainInc():
            if cast.isConnected():
                cast.userFunction(CMD_GAIN_INC, 0)

        # try capture image
        def tryCaptureImage():
            if cast.isConnected():
                cast.userFunction(CMD_CAPTURE_IMAGE, 0)

        # try capture cine
        def tryCaptureCine():
            if cast.isConnected():
                cast.userFunction(CMD_CAPTURE_CINE, 0)

        # try to save a local image
        def trySaveImage():
            self.img.saveImage()

        # try b mode
        def tryBMode():
            if cast.isConnected():
                cast.userFunction(CMD_B_MODE, 0)

        # try cfi mode
        def tryCfiMode():
            if cast.isConnected():
                cast.userFunction(CMD_CFI_MODE, 0)

        conn.clicked.connect(tryConnect)
        self.run.clicked.connect(tryFreeze)
        quit.clicked.connect(self.shutdown)
        depthUp.clicked.connect(tryDepthUp)
        depthDown.clicked.connect(tryDepthDown)
        gainInc.clicked.connect(tryGainInc)
        gainDec.clicked.connect(tryGainDec)
        captureImage.clicked.connect(tryCaptureImage)
        captureCine.clicked.connect(tryCaptureCine)
        saveImage.clicked.connect(trySaveImage)
        bMode.clicked.connect(tryBMode)
        cfiMode.clicked.connect(tryCfiMode)

        # add widgets to layout
        self.img = ImageView(cast)
        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.img)

        inplayout = QtWidgets.QHBoxLayout()
        layout.addLayout(inplayout)
        inplayout.addWidget(ip)
        inplayout.addWidget(port)

        connlayout = QtWidgets.QHBoxLayout()
        layout.addLayout(connlayout)
        connlayout.addWidget(conn)
        connlayout.addWidget(self.run)
        connlayout.addWidget(quit)
        central.setLayout(layout)

        prmlayout = QtWidgets.QHBoxLayout()
        layout.addLayout(prmlayout)
        prmlayout.addWidget(depthUp)
        prmlayout.addWidget(depthDown)
        prmlayout.addWidget(gainDec)
        prmlayout.addWidget(gainInc)

        caplayout = QtWidgets.QHBoxLayout()
        layout.addLayout(caplayout)
        caplayout.addWidget(captureImage)
        caplayout.addWidget(captureCine)
        caplayout.addWidget(saveImage)

        modelayout = QtWidgets.QHBoxLayout()
        layout.addLayout(modelayout)
        modelayout.addWidget(bMode)
        modelayout.addWidget(cfiMode)

        # connect signals
        signaller.freeze.connect(self.freeze)
        signaller.button.connect(self.button)
        signaller.image.connect(self.image)

        # get home path
        path = os.path.expanduser("~/")
        if cast.init(path, 640, 480):
            self.statusBar().showMessage("Initialized")
        else:
            self.statusBar().showMessage("Failed to initialize")

    # handles freeze messages
    @Slot(bool)
    def freeze(self, frozen):
        if frozen:
            self.run.setText("Run")
            self.statusBar().showMessage("Image Stopped")
        else:
            self.run.setText("Freeze")
            self.statusBar().showMessage("Image Running (check firewall settings if no image seen)")

    # handles button messages
    @Slot(int, int)
    def button(self, btn, clicks):
        self.statusBar().showMessage(f"Button {btn} pressed w/ {clicks} clicks")

    # handles new images
    @Slot(QtGui.QImage)
    def image(self, img):
        self.img.updateImage(img)

    # handles shutdown
    @Slot()
    def shutdown(self):
        if sys.platform.startswith("linux"):
            # unload the shared library before destroying the cast object
            ctypes.CDLL("libc.so.6").dlclose(libcast_handle)
        self.cast.destroy()
        QtWidgets.QApplication.quit()


## called when a new processed image is streamed
# @param image the scan-converted image data
# @param width width of the image in pixels
# @param height height of the image in pixels
# @param sz full size of image
# @param micronsPerPixel microns per pixel
# @param timestamp the image timestamp in nanoseconds
# @param angle acquisition angle for volumetric data
# @param imu inertial data tagged with the frame
def newProcessedImage(image, width, height, sz, micronsPerPixel, timestamp, angle, imu):
    bpp = sz / (width * height)
    if bpp == 4:
        img = QtGui.QImage(image, width, height, QtGui.QImage.Format_ARGB32)
    else:
        img = QtGui.QImage(image, width, height, QtGui.QImage.Format_Grayscale8)
    # a deep copy is important here, as the memory from 'image' won't be valid after the event posting
    signaller.usimage = img.copy()
    evt = ImageEvent()
    QtCore.QCoreApplication.postEvent(signaller, evt)


## called when a new raw image is streamed
# @param image the raw pre scan-converted image data, uncompressed 8-bit or jpeg compressed
# @param lines number of lines in the data
# @param samples number of samples in the data
# @param bps bits per sample
# @param axial microns per sample
# @param lateral microns per line
# @param timestamp the image timestamp in nanoseconds
# @param jpg jpeg compression size if the data is in jpeg format
# @param rf flag for if the image received is radiofrequency data
# @param angle acquisition angle for volumetric data
def newRawImage(image, lines, samples, bps, axial, lateral, timestamp, jpg, rf, angle):
    return


## called when a new spectrum image is streamed
# @param image the spectral image
# @param lines number of lines in the spectrum
# @param samples number of samples per line
# @param bps bits per sample
# @param period line repetition period of spectrum
# @param micronsPerSample microns per sample for an m spectrum
# @param velocityPerSample velocity per sample for a pw spectrum
# @param pw flag that is true for a pw spectrum, false for an m spectrum
def newSpectrumImage(image, lines, samples, bps, period, micronsPerSample, velocityPerSample, pw):
    return


## called when a new imu data is streamed
# @param imu inertial data tagged with the frame
def newImuData(imu):
    return


## called when freeze state changes
# @param frozen the freeze state
def freezeFn(frozen):
    evt = FreezeEvent(frozen)
    QtCore.QCoreApplication.postEvent(signaller, evt)


## called when a button is pressed
# @param button the button that was pressed
# @param clicks number of clicks performed
def buttonsFn(button, clicks):
    evt = ButtonEvent(button, clicks)
    QtCore.QCoreApplication.postEvent(signaller, evt)


## main function
def main():
    cast = pyclariuscast.Caster(newProcessedImage, newRawImage, newSpectrumImage, newImuData, freezeFn, buttonsFn)
    app = QtWidgets.QApplication(sys.argv)
    widget = MainWidget(cast)
    widget.resize(640, 480)
    widget.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()



================================================
FILE: examples/python/scanner.mtl
================================================
# Blender MTL File: 'None'
# Material Count: 8

newmtl BatteryButton
Ns 311.764717
Ka 1.000000 1.000000 1.000000
Kd 0.431584 0.441609 0.446672
Ks 0.112941 0.112941 0.112941
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 2

newmtl Body
Ns 17.647057
Ka 1.000000 1.000000 1.000000
Kd 0.683994 0.683994 0.671039
Ks 0.112941 0.112941 0.112941
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 2

newmtl Grip
Ns 3.921567
Ka 1.000000 1.000000 1.000000
Kd 0.012797 0.012797 0.012797
Ks 0.112941 0.112941 0.112941
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 2

newmtl LED
Ns 311.764717
Ka 1.000000 1.000000 1.000000
Kd 0.116354 0.602353 0.021401
Ks 0.225882 0.225882 0.225882
Ke 0.145443 0.752941 0.026752
Ni 1.000000
d 1.000000
illum 2

newmtl Logo
Ns 311.764717
Ka 1.000000 1.000000 1.000000
Kd 0.431584 0.441609 0.446672
Ks 0.112941 0.112941 0.112941
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 2

newmtl PowerPin
Ns 17.647057
Ka 1.000000 1.000000 1.000000
Kd 0.701102 0.376262 0.014444
Ks 0.127843 0.127843 0.127843
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 2

newmtl PowerPlate
Ns 3.921567
Ka 1.000000 1.000000 1.000000
Kd 0.012797 0.012797 0.012797
Ks 0.112941 0.112941 0.112941
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 2

newmtl ScanHeadCone
Ns 17.647057
Ka 1.000000 1.000000 1.000000
Kd 0.683994 0.683994 0.671039
Ks 0.127843 0.127843 0.127843
Ke 0.000000 0.000000 0.000000
Ni 1.000000
d 1.000000
illum 2



================================================
FILE: include/cast/cast.h
================================================
#pragma once

#include "cast_export.h"
#include "cast_cb.h"

/// initialization parameters for castInit
typedef struct _CusInitParams
{    struct Args
    {
        int argc;       ///< the argument count for input parameters to pass to the library
        char** argv;    ///< the arguments to pass to the library, possibly required for qt graphics buffer initialization
    }
    args;
    const char* storeDir;                           ///< the directory to store security keys
    CusNewProcessedImageFn newProcessedImageFn;     ///< new processed image callback (scan-converted image)
    CusNewRawImageFn newRawImageFn;                 ///< new raw image callback (pre scan-converted image or rf data)
    CusNewSpectralImageFn newSpectralImageFn;       ///< new processed spectral image callback
    CusNewImuDataFn newImuDataFn;                   ///< new imu data callback
    CusFreezeFn freezeFn;                           ///< freeze state callback
    CusButtonFn buttonFn;                           ///< button press callback
    CusProgressFn progressFn;                       ///< readback progress callback
    CusErrorFn errorFn;                             ///< error message callback
    int width;                                      ///< the width of the output buffer
    int height;                                     ///< the height of the output buffer

} CusInitParams;

#ifdef __cplusplus
extern "C" {
#endif

    /// initializes the casting functionality
    /// @param[in] params the sdk configuration parameters
    /// @return success of the call
    /// @retval 0 the initialization was successful
    /// @retval -1 the initialization was not successful
    /// @note must be called before any other functions will succeed
    CAST_EXPORT int castInit(const CusInitParams* params);

    /// get init params with default values
    /// @return a zero initialized struct
    CAST_EXPORT CusInitParams castDefaultInitParams(void);

    /// cleans up memory allocated by the caster
    /// @retval 0 the destroy attempt was successful
    /// @retval -1 the destroy attempt was not successful
    /// @note should be called prior to exiting the application
    CAST_EXPORT int castDestroy(void);

    /// retrieves the firmware version for a given platform
    /// @param[in] platform the platform to retrieve the firmware version for
    /// @param[out] version holds the firmware version for the given platform
    /// @param[in] sz size of the version string buffer, suggest at least 64 bytes allocated
    /// @return success of the call
    /// @retval 0 the information was retrieved
    /// @retval -1 the information could not be retrieved
    CAST_EXPORT int castFwVersion(CusPlatform platform, char* version, int sz);

    /// tries to connect to a probe that is on the same network as the caller
    /// @param[in] ipAddress the ip address of the probe
    /// @param[in] port the probe's tcp casting port
    /// @param[in] cert the certificate to authenticate the probe being connected to
    /// @param[in] fn callback to obtain success of call. the return value will be the udp port used if successful
    /// @return success of the call
    /// @note pass "research" as the certificate to bypass authentication
    /// @retval 0 the connection attempt was successful
    /// @retval -1 the connection attempt was not successful
    CAST_EXPORT int castConnect(const char* ipAddress, unsigned int port, const char* cert, CusConnectFn fn);

    /// disconnects from an existing connection
    /// @param[in] fn callback to obtain success of call
    /// @return success of the call
    /// @retval 0 the disconnect to the specified connection was successful
    /// @retval -1 the disconnect was unsuccessful
    CAST_EXPORT int castDisconnect(CusReturnFn fn);

    /// retrieves the current connected state of the module
    /// @return the connected state of the module
    /// @retval 0 there is currently no connection
    /// @retval 1 there is currently a connection
    /// @retval -1 the module is not initialized
    CAST_EXPORT int castIsConnected(void);

    /// retrieves the current probe information
    /// @param[out] info the probe information
    /// @return success of the call
    /// @retval 0 the information was retrieved
    /// @retval -1 the information could not be retrieved
    CAST_EXPORT int castProbeInfo(CusProbeInfo* info);

    /// sets the dimensions of the output display for scan conversion
    /// @param[in] w the number of pixels in the horizontal direction
    /// @param[in] h the number of pixels in the vertical direction
    /// @return success of the call
    /// @retval 0 the output size was successfully programmed
    /// @retval -1 the output size could not be set
    /// @note the output will always result in a 1:1 pixel ratio, depending on geometry of scanning array, and parameters
    ///       the frame will have various sizes of black borders around the image
    CAST_EXPORT int castSetOutputSize(int w, int h);

    /// sets a flag to separate overlays into separate images, for example if color/power Doppler or strain
    /// imaging is enabled, two callbacks will be generated, one with the grayscale frame, and the other with the overlay
    /// @param[in] en the enable flag for separating overlays
    /// @return success of the call
    /// @retval 0 the flag was successfully programmed
    /// @retval -1 the flag could not be set
    CAST_EXPORT int castSeparateOverlays(int en);

    /// sets the format for processed images, by default the format will be raw argb
    /// @param[in] format the format of the image
    /// @return success of the call
    /// @retval 0 the format was successfully set
    /// @retval -1 the format could not be set
    CAST_EXPORT int castSetFormat(CusImageFormat format);

    /// makes a request to return the availability of all the raw data currently buffered on the probe
    /// @param[in] fn result callback function that will return all the timestamps of the data blocks that are buffered
    /// @return success of the call
    /// @retval 0 the request was successfully made
    /// @retval -1 the request could not be made
    /// @note the probe must be frozen with raw data buffering enabled prior to calling the function
    CAST_EXPORT int castRawDataAvailability(CusRawAvailabilityFn fn);

    /// makes a request for raw data from the probe
    /// @param[in] start the first frame to request, as determined by timestamp in nanoseconds, set to 0 along with end to requests all data in buffer
    /// @param[in] end the last frame to request, as determined by timestamp in nanoseconds, set to 0 along with start to requests all data in buffer
    /// @param[in] lzo flag to specify a tarball with lzo compressed raw data inside (default) vs no compression of raw data
    /// @param[in] fn result callback function, will return size of buffer required upon success, 0 if no raw data was buffered, or -1 if request could not be made
    /// @return success of the call
    /// @retval 0 the request was successfully made
    /// @retval -1 the request could not be made
    /// @note the probe must be frozen and in a raw data buffering mode in order for the call to succeed
    CAST_EXPORT int castRequestRawData(long long int start, long long int end, int lzo, CusRawRequestFn fn);

    /// retrieves raw data from a previous request
    /// @param[out] data a pointer to a buffer that has been allocated to read the raw data into, this must be pre-allocated with
    ///             the size returned from a previous call to castRequestRawData
    /// @param[in] fn callback to obtain success of call, upon returning 0, the data pointer can be accessed for the size resulting from the raw data request
    /// @return success of the call
    /// @retval 0 the data was successfully read into the buffer
    /// @retval -1 the data could not be read
    /// @note the probe must be frozen and a successful call to castRequestRawData must have taken place in order for the call to succeed
    CAST_EXPORT int castReadRawData(void** data, CusRawFn fn);

    /// performs a user function on a connected probe
    /// @param[in] cmd the user command to run
    /// @param[in] val the value to set if the function supports setting of values
    ///            SetDepth supports setting depth in cm
    ///            SetGain supports setting gain in %
    /// @param[in] fn callback to obtain success of call
    /// @return success of the call
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    CAST_EXPORT int castUserFunction(CusUserFunction cmd, double val, CusReturnFn fn);

    /// sets a parameter to a specific value for researchers to gain access to lower level control of device
    /// @param[in] prm the parameter to change
    /// @param[in] val the value to set the parameter to
    /// @param[in] fn callback to obtain success of call
    /// @return success of the call
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    /// @note see external documentation for supported parameters
    /// @warning changing parameters through this function may result in unstable operation, degradation of image quality, or operation outside of the safety limits that clarius tests to
    CAST_EXPORT int castSetParameter(const char* prm, double val, CusReturnFn fn);

    /// enables or disables a parameter for researchers to gain access to lower level control of device
    /// @param[in] prm the parameter to change
    /// @param[in] en the enable flag, 0 to disable, 1 to enable
    /// @param[in] fn callback to obtain success of call
    /// @return success of the call
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    /// @note see external documentation for supported parameters
    /// @warning changing parameters through this function may result in unstable operation, degradation of image quality, or operation outside of the safety limits that clarius tests to
    CAST_EXPORT int castEnableParameter(const char* prm, int en, CusReturnFn fn);

    /// sets a pulse shape parameter to a specific value for researchers to gain access to lower level control of device
    /// @param[in] prm the parameter to change
    /// @param[in] shape the shape to set the pulse as
    /// @param[in] fn callback to obtain success of call
    /// @return success of the call
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    /// @note see external documentation for supported parameters
    /// @warning changing parameters through this function may result in unstable operation, degradation of image quality, or operation outside of the safety limits that clarius tests to
    CAST_EXPORT int castSetPulse(const char* prm, const char* shape, CusReturnFn fn);

    /// begins a capture with the current image settings
    /// @param[in] timestamp the timestamp of the frame to be captured
    /// @retval the ID of the newly created capture
    /// @retval -1 the call was not successful
    CAST_EXPORT int castStartCapture(long long int timestamp);

    /// adds an image overlay to a capture which was started with castStartCapture
    /// @param[in] id the ID of the capture which is to be added to
    /// @param[in] data pointer to the image data which is to be added (assumed 8-bit grayscale)
    /// @param[in] width width of the image data which is to be added; must match the width from castInit
    /// @param[in] height height of the image data which is to be added; must match the height from castInit
    /// @param[in] red the value of red use in colorizing the overlay, should be between 0.0 and 1.0
    /// @param[in] green the value of green use in colorizing the overlay, should be between 0.0 and 1.0
    /// @param[in] blue the value of blue use in colorizing the overlay, should be between 0.0 and 1.0
    /// @param[in] alpha the value of alpha (opacity) use in colorizing the overlay, should be between 0.0 and 1.0
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    CAST_EXPORT int castAddImageOverlay(int id, const void* data, int width, int height, float red, float green, float blue, float alpha);

    /// adds a label overlay to a capture which was started with castStartCapture
    /// @param[in] id the ID of the capture which is to be added to
    /// @param[in] text string of the label to be added
    /// @param[in] x x-position of the label in pixels (same scale as the width from castInit)
    /// @param[in] y y-position of the label in pixels (same scale as the height from castInit)
    /// @param[in] width width of the label in pixels (same scale as the width from castInit)
    /// @param[in] height height of the label in pixels (same scale as the height from castInit)
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    CAST_EXPORT int castAddLabelOverlay(int id, const char* text, double x, double y, double width, double height);

    /// adds a 2-point distance or trace measurement to a capture which was started with castStartCapture
    /// @details for a distance measurement, 2 points should be given
    /// @param[in] id the ID of the capture which is to be added to
    /// @param[in] type the type of measurement to add
    /// @param[in] label string label for the measurement
    /// @param[in] pts pointer to an array of doubles (x,y positions pixels, same scale as the width/height from castInit)
    /// @param[in] count number of *doubles* in the pts array (not number of points)
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    CAST_EXPORT int castAddMeasurement(int id, CusMeasurementType type, const char* label, const double* pts, int count);

    /// completes a capture which was started with castStartCapture
    /// @param[in] id the ID of the capture which is to be finished
    /// @param[in] fn callback to obtain the success of the call, -1 if the request failed, 0 if it succeeded
    /// @retval 0 the call was successful
    /// @retval -1 the call was not successful
    CAST_EXPORT int castFinishCapture(int id, CusReturnFn fn);

#ifdef __cplusplus
}
#endif



================================================
FILE: include/cast/cast_cb.h
================================================
#pragma once

#include "cast_def.h"

/// return status callback function
/// @param[in] imagePort the udp port on a successful connection attempt, CUS_FAILURE on an unsuccessful attempt or other error
/// @param[in] imuPort the new imu data UDP streaming port, CUS_FAILURE on an unsuccessful attempt or other error
/// @param[in] swRevMatch flag if the sw revisions between the api and the clarius app match, CUS_SUCCESS if a match, CUS_FAILURE on a mismatch
typedef void (*CusConnectFn)(int imagePort, int imuPort, int swRevMatch);
/// return status callback function
/// @param[in] retCode the return code (CUS_SUCCESS or CUS_FAILURE)
typedef void (*CusReturnFn)(int retCode);
/// new data callback function
/// @param[in] img pointer to the new grayscale image information
/// @param[in] nfo image information associated with the image data
/// @param[in] npos number of positional information data tagged with the image
/// @param[in] pos the positional information data tagged with the image
typedef void (*CusNewRawImageFn)(const void* img, const CusRawImageInfo* nfo, int npos, const CusPosInfo* pos);
/// new image callback function
/// @param[in] img pointer to the new grayscale image information
/// @param[in] nfo image information associated with the image data
/// @param[in] npos number of positional information data tagged with the image
/// @param[in] pos the positional information data tagged with the image
typedef void (*CusNewProcessedImageFn)(const void* img, const CusProcessedImageInfo* nfo, int npos, const CusPosInfo* pos);
/// new spectral image callback function
/// @param[in] img pointer to the new grayscale image information
/// @param[in] nfo image information associated with the image data
typedef void (*CusNewSpectralImageFn)(const void* img, const CusSpectralImageInfo* nfo);
/// freeze callback function
/// @param[in] state 1 = frozen, 0 = imaging
typedef void (*CusFreezeFn)(int state);
/// button callback function
/// @param[in] btn the button that was pressed
/// @param[in] clicks # of clicks performed
typedef void (*CusButtonFn)(CusButton btn, int clicks);
/// progress callback function
/// @param[in] progress the current progress
typedef void (*CusProgressFn)(int progress);
/// raw data availability callback function
/// @param[in] res the request result: 0 on success, -1 on error
/// @param[in] n_b the number of b timestamps within the array of b
/// @param[in] b an array of timestamps for raw b data, null on error
/// @param[in] n_iqrf the number of iq/rf timestamps within the array of iqrf
/// @param[in] iqrf an array of timestamps for raw iq/rf data, null on error
typedef void (*CusRawAvailabilityFn)(int res, int n_b, const long long* b, int n_iqrf, const long long* iqrf);
/// raw data request callback function
/// @param[in] res the raw data result, typically the size of the data package requested or actually downloaded
/// @param[in] extension the file extension of the packaged data
typedef void (*CusRawRequestFn)(int res, const char* extension);
/// raw data callback function
/// @param[in] res the raw data result, typically the size of the data package requested or actually downloaded
typedef void (*CusRawFn)(int res);
/// error callback function
/// @param[in] msg the error message with associated error that occurred
typedef void (*CusErrorFn)(const char* msg);
/// new imu data callback function
/// @param[in] pos the positional information data tagged with the image
typedef void (*CusNewImuDataFn)(const CusPosInfo* pos);



================================================
FILE: include/cast/cast_def.h
================================================
#pragma once

// SDK: cast
// Version: 12.2.0

#define CUS_MAXTGC  10
#define CUS_SUCCESS 0
#define CUS_FAILURE (-1)

/// The probe buttons
typedef enum _CusButton
{
    ButtonUp,           ///< Up button
    ButtonDown,         ///< Down button
    ButtonHandle,       ///< Handle button (custom probes only)

} CusButton;

/// The compression types available
typedef enum _CusImageFormat
{
    Uncompressed,       ///< Processed images are sent in a raw and uncompressed in 32 bits ARGB
    Uncompressed8Bit,   ///< Processed images are sent in a raw and uncompressed in 8 bit grayscale
    Jpeg,               ///< Processed images are sent as a jpeg (with header)
    Png,                ///< Processed images are sent as a png (with header)

} CusImageFormat;

/// Major Clarius platforms
typedef enum _CusPlatform
{
    V1,                 ///< First generation
    HD,                 ///< Second generation (HD)
    HD3,                ///< Third generation (HD3)
    HD4,                ///< Fourth generation (HD4)

} CusPlatform;

/// The possible user functions from a button or listener
typedef enum _CusUserFunction
{
    Freeze = 1,         ///< toggle freeze
    CaptureImage,       ///< capture still image
    CaptureCine,        ///< capture cine
    DepthDec,           ///< decrease depth
    DepthInc,           ///< increase depth
    GainDec,            ///< decrease gain
    GainInc,            ///< increase gain
    AutoGain,           ///< toggle auto gain
    Zoom,               ///< toggle zoom
    Flip,               ///< toggle horizontal flip
    PlayCine,           ///< play cine when frozen
    BMode,              ///< enter b mode
    TMode,              ///< enter t mode
    MMode,              ///< enter m mode
    ColorDoppler,       ///< enter color doppler mode
    PowerDoppler,       ///< enter power doppler mode
    PwDoppler,          ///< enter pulsed wave doppler mode (when available)
    NeedleEnhance,      ///< enter needle enhance mode (when available)
    Strain,             ///< enter strain elastography mode (when available)
    Ceus,               ///< enter contrast enhanced mode (when available)
    RfMode,             ///< enter rf mode (when available)
    NeedleSide,         ///< toggle needle enhance side
    SetDepth,           ///< set depth in cm
    SetGain,            ///< set gain in %
    CenterGuide,        ///< toggle center guide
    FullScreen,         ///< toggle full screen
    VoiceCommand,       ///< toggle voice controls
    ContrastDec,        ///< decrease contrast
    ContrastInc,        ///< increase contrast
    ColorGainDec,       ///< decrease color gain
    ColorGainInc,       ///< increase color gain
    ColorPrfDec,        ///< decrease color prf
    ColorPrfInc,        ///< increase color prf
    SwitchArray,        ///< switch array
    Split1,             ///< split screen into 1 display
    Split2,             ///< split screen into 2 displays
    Split4,             ///< split screen into 4 displays
    SplitNext,          ///< activate the next display
    Annotate,           ///< opens annotations
    ClearScreen,        ///< clears screen
    PreviousFrame,      ///< previous cine frame
    NextFrame,          ///< next cine frame

} CusUserFunction;

/// Supported measurement types
typedef enum _CusMeasurementType
{
    CusMeasurementTypeDistance = 1, ///< point-to-point distance
    CusMeasurementTypeTraceDistance, ///< trace distance
    CusMeasurementTypeTraceArea, ///< trace area

} CusMeasurementType;

/// TGC information
typedef struct _CusTgcInfo
{
    double depth;       ///< Depth in millimeters
    double gain;        ///< Gain in decibels

} CusTgcInfo;

/// Positional data information structure
typedef struct _CusPosInfo
{
    long long int tm;   ///< Timestamp in nanoseconds
    double gx;          ///< Gyroscope x; angular velocity is given in radians per second (RPS)
    double gy;          ///< Gyroscope y; angular velocity is given in radians per second (RPS)
    double gz;          ///< Gyroscope z; angular velocity is given in radians per second (RPS)
    double ax;          ///< Accelerometer x; acceleration is normalized to gravity [~9.81m/s^2] (m/s^2)/(m/s^2)
    double ay;          ///< Accelerometer y; acceleration is normalized to gravity [~9.81m/s^2] (m/s^2)/(m/s^2)
    double az;          ///< Accelerometer z; acceleration is normalized to gravity [~9.81m/s^2] (m/s^2)/(m/s^2)
    double mx;          ///< Magnetometer x; magnetic flux density is normalized to the earth's field [~50 mT] (T/T)
    double my;          ///< Magnetometer y; magnetic flux density is normalized to the earth's field [~50 mT] (T/T)
    double mz;          ///< Magnetometer z; magnetic flux density is normalized to the earth's field [~50 mT] (T/T)
    double qw;          ///< W component (real) of the orientation quaternion
    double qx;          ///< X component (imaginary) of the orientation quaternion
    double qy;          ///< Y component (imaginary) of the orientation quaternion
    double qz;          ///< Z component (imaginary) of the orientation quaternion

} CusPosInfo;

/// Probe information
typedef struct _CusProbeInfo
{
    int version;        ///< Version (1 = clarius 1st generation, 2 = clarius HD, 3 = clarius HD3)
    int elements;       ///< Number of probe elements
    int pitch;          ///< Element pitch
    int radius;         ///< Radius in millimeters
    int frequency;      ///< Center frequency in Hz

} CusProbeInfo;

/// Processed image information supplied with each frame
typedef struct _CusProcessedImageInfo
{
    int width;          ///< width of the image in pixels
    int height;         ///< height of the image in pixels
    int bitsPerPixel;   ///< bits per pixel
    int imageSize;      ///< total size of image in bytes
    double micronsPerPixel; ///< microns per pixel (always 1:1 aspect ratio axially/laterally)
    double originX;     ///< image origin in microns in the horizontal axis
    double originY;     ///< image origin in microns in the vertical axis
    long long int tm;   ///< timestamp of images
    double angle;       ///< acquisition angle for volumetric data
    double fps;         ///< frame rate in hz
    int overlay;        ///< flag that the image is an overlay without grayscale (ie. color doppler or strain)
    CusImageFormat format; ///< flag specifying the format of the image (see format definitions above)
    CusTgcInfo tgc [CUS_MAXTGC]; ///< tgc points

} CusProcessedImageInfo;

/// Raw image information supplied with each frame
typedef struct _CusRawImageInfo
{
    int lines;          ///< number of ultrasound lines in the image
    int samples;        ///< number of samples per line in the image
    int bitsPerSample;  ///< bits per sample
    double axialSize;   ///< axial microns per sample
    double lateralSize; ///< lateral microns per line
    long long int tm;   ///< timestamp of image
    int jpeg;           ///< size of the jpeg image, 0 if not a jpeg compressed image
    int rf;             ///< flag specifying data is rf and not envelope
    double angle;       ///< acquisition angle for volumetric data
    double fps;         ///< frame rate in hz
    CusTgcInfo tgc [CUS_MAXTGC]; ///< tgc points

} CusRawImageInfo;

/// Spectral image information supplied with each block
typedef struct _CusSpectralImageInfo
{
    int lines;          ///< Number of lines in the block
    int samples;        ///< Number of samples per line
    int bitsPerSample;  ///< Bits per sample
    double period;      ///< Line acquisition period in seconds
    double micronsPerSample; ///< Microns per pixel/sample in an M spectrum
    double velocityPerSample; ///< Velocity in m/s per pixel/sample in a PW spectrum
    int pw;             ///< Flag specifying the data is PW and not M

} CusSpectralImageInfo;

/// 2D point with double precision
typedef struct _CusPointF
{
    double x;           ///< X coordinate
    double y;           ///< Y coordinate

} CusPointF;

/// 2D line with double precision
typedef struct _CusLineF
{
    CusPointF p1;       ///< First point in the line
    CusPointF p2;       ///< Second point in the line

} CusLineF;

#ifndef CAST_DEPRECATED
#  ifdef _MSC_VER
#    define CAST_DEPRECATED __declspec(deprecated)
#  else
#    define CAST_DEPRECATED __attribute__ ((__deprecated__))
#  endif
#endif

CAST_DEPRECATED typedef struct _CusLineF CusLine;
CAST_DEPRECATED typedef struct _CusPointF CusPoint;



================================================
FILE: include/cast/cast_export.h
================================================

#ifndef CAST_EXPORT_H
#define CAST_EXPORT_H

#ifdef CAST_STATIC_DEFINE
#  define CAST_EXPORT
#  define CAST_NO_EXPORT
#else
#  ifndef CAST_EXPORT
#    ifdef cast_EXPORTS
        /* We are building this library */
#      define CAST_EXPORT __declspec(dllexport)
#    else
        /* We are using this library */
#      define CAST_EXPORT __declspec(dllimport)
#    endif
#  endif

#  ifndef CAST_NO_EXPORT
#    define CAST_NO_EXPORT 
#  endif
#endif

#ifndef CAST_DEPRECATED
#  define CAST_DEPRECATED __declspec(deprecated)
#endif

#ifndef CAST_DEPRECATED_EXPORT
#  define CAST_DEPRECATED_EXPORT CAST_EXPORT CAST_DEPRECATED
#endif

#ifndef CAST_DEPRECATED_NO_EXPORT
#  define CAST_DEPRECATED_NO_EXPORT CAST_NO_EXPORT CAST_DEPRECATED
#endif

/* NOLINTNEXTLINE(readability-avoid-unconditional-preprocessor-if) */
#if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef CAST_NO_DEPRECATED
#    define CAST_NO_DEPRECATED
#  endif
#endif

#endif /* CAST_EXPORT_H */



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Environment:**
- SDK variant [e.g. python wrappers, iOS Framework]:
- Development platform [e.g. Linux, Xcode]:
- SDK version:
- Clarius App version:


